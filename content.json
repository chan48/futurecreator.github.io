{"meta":{"title":"Writer, IT Blog","subtitle":"Eric Han's IT Blog using Hexo","description":"Eric Han's IT Blog using Hexo","author":"Eric Han","url":"http://futurecreator.github.io"},"pages":[],"posts":[{"title":"정올(JUNGOL) 약수 구하기 (1402) 알고리즘 기초 문제 풀이","slug":"jungol-algorithm-1402","date":"2017-01-12T07:08:57.000Z","updated":"2017-01-12T07:13:52.000Z","comments":true,"path":"2017/01/12/jungol-algorithm-1402/","link":"","permalink":"http://futurecreator.github.io/2017/01/12/jungol-algorithm-1402/","excerpt":"","text":"실력키우기 &gt; 수학 &gt; 약수 구하기 (1402) 문제 클릭두 수 n 과 k 를 입력받아, n 의 k 번째로 작은 약수를 구하는 문제입니다. k 번째 약수를 확인해야하기 때문에 약수 전체를 다 확인해봐야합니다. 약수는 나눠 떨어지는 수이기 때문에 1부터 시작해서 자기 자신까지 for 문을 이용해서 하나씩 나눠보면서 검증하면 됩니다. k 번째에 약수에 도달할 경우 출력 후 중지하면 되고, 다 돌아도 k 번째 약수를 찾을 수 없는 경우 0을 출력합니다. 12345678910111213141516171819202122232425262728293031323334/************************************************************** Problem: 1402 User: future_creator Language: Java Result: Success Time:213 ms Memory:10988 kb****************************************************************/import java.util.Scanner;public class Main &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); int n = sc.nextInt(); int m = sc.nextInt(); int cnt = 0; for (int i = 1; i &lt;= n; i++) &#123; if (n % i == 0) &#123; cnt++; if (cnt == m) &#123; System.out.println(i); System.exit(0); ; &#125; &#125; &#125; System.out.println(0); &#125;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://futurecreator.github.io/categories/Algorithm/"},{"name":"Jungol","slug":"Algorithm/Jungol","permalink":"http://futurecreator.github.io/categories/Algorithm/Jungol/"}],"tags":[{"name":"basic","slug":"basic","permalink":"http://futurecreator.github.io/tags/basic/"},{"name":"algorithm","slug":"algorithm","permalink":"http://futurecreator.github.io/tags/algorithm/"}]},{"title":"정올(JUNGOL) 곱셈 (1692) 알고리즘 기초 문제 풀이","slug":"jungol-algorithm-1692","date":"2017-01-12T06:30:28.000Z","updated":"2017-01-12T07:09:42.000Z","comments":true,"path":"2017/01/12/jungol-algorithm-1692/","link":"","permalink":"http://futurecreator.github.io/2017/01/12/jungol-algorithm-1692/","excerpt":"","text":"실력키우기 &gt; 수학 &gt; 곱셈 (1692) 문제 클릭 1, 2 두 수를 입력받아서 곱셈하는 과정에서 3, 4, 5, 6을 출력하는 문제입니다. 저는 간단하게 풀기 위해서 입력받은 두 수의 각 자리수를 배열에 넣어서 for 문을 이용해 곱셈 처리했습니다. 출력되는 순서는 그림의 385에서 5 -&gt; 8 -&gt; 3 순서로 진행되기 때문에 그 부분에 주의하시면 되겠습니다. 마지막 6번은 그냥 두 수를 곱해서 출력하면 됩니다. 123456789101112131415161718192021222324252627282930313233343536373839404142/************************************************************** Problem: 1692 User: future_creator Language: Java Result: Success Time:169 ms Memory:10520 kb****************************************************************/import java.util.Scanner;public class Main &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); int n = sc.nextInt(); int m = sc.nextInt(); int[] arr1 = new int[3]; arr1[0] = (n / 100) * 100; // 100의 자리 arr1[1] = (n % 100 / 10) * 10; // 10의 자리 arr1[2] = n % 10; // 1의 자리 int[] arr2 = new int[3]; arr2[0] = m / 100; arr2[1] = m % 100 / 10; arr2[2] = m % 10; int k = 0; for (int i = 2; i &gt; -1; i--) &#123; k = 0; for (int j = 0; j &lt; 3; j++) &#123; k += arr1[j] * arr2[i]; &#125; System.out.println(k); &#125; System.out.println(n * m); &#125;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://futurecreator.github.io/categories/Algorithm/"},{"name":"Jungol","slug":"Algorithm/Jungol","permalink":"http://futurecreator.github.io/categories/Algorithm/Jungol/"}],"tags":[{"name":"basic","slug":"basic","permalink":"http://futurecreator.github.io/tags/basic/"},{"name":"algorithm","slug":"algorithm","permalink":"http://futurecreator.github.io/tags/algorithm/"}]},{"title":"정올(JUNGOL) 숫자의 개수 (1430) 알고리즘 기초 문제 풀이","slug":"jungol-algorithm-1430","date":"2017-01-12T05:10:43.000Z","updated":"2017-01-12T06:27:58.000Z","comments":true,"path":"2017/01/12/jungol-algorithm-1430/","link":"","permalink":"http://futurecreator.github.io/2017/01/12/jungol-algorithm-1430/","excerpt":"","text":"실력키우기 &gt; 수학 &gt; 숫자의 개수 (1430) 문제 클릭입력받은 숫자 전체에 0 ~ 9 까지 어떤 숫자가 몇번 쓰였는지 카운트하는 문제입니다. 횟수 자체를 저장할 배열을 선언해 놓고, 숫자 각 자리를 확인하면서 배열에 숫자를 카운팅합니다. 숫자 자체로는 각 자리수를 확인하기가 어렵기 때문에 문자열로 변환하는 것이 좋습니다. 빈 문자열을 더해주면 자동형변환이 일어나 쉽게 문자열로 변환할 수 있습니다. 그 후 for 문과 charAt() 메소드를 이용하면 각 자리수에 접근할 수 있습니다. 1234567891011121314151617181920212223242526272829303132/************************************************************** Problem: 1430 User: future_creator Language: Java Result: Success Time:171 ms Memory:10188 kb****************************************************************/import java.util.Scanner;public class Main &#123; static int[] arr; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); int n = sc.nextInt() * sc.nextInt() * sc.nextInt(); arr = new int[10]; String s = n + \"\"; for (int i = 0; i &lt; s.length(); i++) &#123; arr[Integer.parseInt(s.charAt(i) + \"\")]++; &#125; for (int i = 0; i &lt; arr.length; i++) &#123; System.out.println(arr[i]); &#125; &#125;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://futurecreator.github.io/categories/Algorithm/"},{"name":"Jungol","slug":"Algorithm/Jungol","permalink":"http://futurecreator.github.io/categories/Algorithm/Jungol/"}],"tags":[{"name":"basic","slug":"basic","permalink":"http://futurecreator.github.io/tags/basic/"},{"name":"algorithm","slug":"algorithm","permalink":"http://futurecreator.github.io/tags/algorithm/"}]},{"title":"정올(JUNGOL) 각 자리수의 합(2812) 알고리즘 기초 문제 풀이","slug":"jungol-algorithm-2812","date":"2017-01-12T04:28:10.000Z","updated":"2017-01-12T06:22:04.000Z","comments":true,"path":"2017/01/12/jungol-algorithm-2812/","link":"","permalink":"http://futurecreator.github.io/2017/01/12/jungol-algorithm-2812/","excerpt":"","text":"실력키우기 &gt; 수학 &gt; 각 자리수의 합 (2812) 문제 클릭실력키우기 &gt; 수학 카테고리의 첫번째 문제입니다. 입력받은 숫자의 각 자리수를 더하면서 10 넘을 때 출력하는 작업을 반복 수행하는 문제입니다. 입력받은 숫자를 처리하는 것이 문제인데, 숫자 자체로는 처리하기 어렵고 문자로 변환해서 처리하는 것이 좋습니다. 간단하게 변화하려면 자동형변환을 이용하는 것이 좋습니다. 숫자에 빈 문자열을 더해서 문자열로 변환됩니다. 문자열에서 각 문자에 대해 접근하기 위해서는 charAt() 메서드를 이용합니다. 반환값은 char 형입니다. for 문과 함께 이용하면 순차적으로 각 문자에 대해 접근할 수 있고, Integer.parseInt() 를 이용해 숫자로 변환 후에 합산해주면 됩니다. 12345String s = n + \"\"; // 문자열로 변환int sum = 0;for (int i = 0; i &lt; s.length(); i++) &#123; sum += Integer.parseInt(s.charAt(i) + \"\");&#125; 전체 소스입니다. 1234567891011121314151617181920212223242526272829303132333435363738/************************************************************** Problem: 2812 User: future_creator Language: Java Result: Success Time:212 ms Memory:10552 kb****************************************************************/import java.util.Scanner;public class Main &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); long n = sc.nextLong(); while (true) &#123; String s = n + \"\"; int sum = 0; for (int i = 0; i &lt; s.length(); i++) &#123; sum += Integer.parseInt(s.charAt(i) + \"\"); &#125; if (sum &lt; 10) &#123; System.out.println(sum); break; &#125; else &#123; System.out.println(sum); n = sum; continue; &#125; &#125; &#125;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://futurecreator.github.io/categories/Algorithm/"},{"name":"Jungol","slug":"Algorithm/Jungol","permalink":"http://futurecreator.github.io/categories/Algorithm/Jungol/"}],"tags":[{"name":"basic","slug":"basic","permalink":"http://futurecreator.github.io/tags/basic/"},{"name":"algorithm","slug":"algorithm","permalink":"http://futurecreator.github.io/tags/algorithm/"}]},{"title":"정올(JUNGOL) 구구단2(1341) 알고리즘 기초 문제 풀이","slug":"jungol-algorithm-1341","date":"2017-01-12T01:18:25.000Z","updated":"2017-01-12T01:30:58.000Z","comments":true,"path":"2017/01/12/jungol-algorithm-1341/","link":"","permalink":"http://futurecreator.github.io/2017/01/12/jungol-algorithm-1341/","excerpt":"","text":"실력키우기 &gt; 도형만들기 &gt; 구구단2 (1341) 문제 클릭이전 구구단 문제 와 동일하게 두 수를 입력받아 구구단을 출력하는 문제입니다. 두 수의 순서에 따라 출력 순서도 달라집니다. 3, 5를 입력한 경우 3, 4, 5단 순으로 출력이 되고 5, 3을 입력한 경우는 5, 4, 3단 순으로 출력이 됩니다. 따라서 이 부분은 두 수를 비교해서 if 문으로 로직을 나누면 되겠습니다. 이전 문제와 다른 점은 출력하는 포맷입니다. 이번에는 단 전체를 순서대로 출력하면 되는데요, 3, 6, 9 곱하는 시점에 줄을 바꿔주면 됩니다. 크게 어렵지 않은 부분입니다. 이번 문제에서도 줄을 맞추실 때 printf 에서 %2d 를 이용하시면 편합니다. 두 자리에 맞춰서 출력이 되고, 구구단에서는 81이 제일 큰 숫자이니 두 자리면 충분합니다. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/************************************************************** Problem: 1341 User: future_creator Language: Java Result: Success Time:214 ms Memory:10328 kb****************************************************************/import java.util.Scanner;public class Main &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); int n = sc.nextInt(); int e = sc.nextInt(); if (n &gt; e) &#123; for (int i = n; i &gt;= e; i--) &#123; for (int j = 1; j &lt; 10; j++) &#123; System.out.printf(\"%d * %d = %2d \", i, j, i * j); if (j % 3 == 0) &#123; System.out.println(); &#125; &#125; System.out.println(); &#125; &#125; else &#123; for (int i = n; i &lt;= e; i++) &#123; for (int j = 1; j &lt; 10; j++) &#123; System.out.printf(\"%d * %d = %2d \", i, j, i * j); if (j % 3 == 0) &#123; System.out.println(); &#125; &#125; System.out.println(); &#125; &#125; &#125;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://futurecreator.github.io/categories/Algorithm/"},{"name":"Jungol","slug":"Algorithm/Jungol","permalink":"http://futurecreator.github.io/categories/Algorithm/Jungol/"}],"tags":[{"name":"basic","slug":"basic","permalink":"http://futurecreator.github.io/tags/basic/"},{"name":"algorithm","slug":"algorithm","permalink":"http://futurecreator.github.io/tags/algorithm/"}]},{"title":"정올(JUNGOL) 구구단(1291) 알고리즘 기초 문제 풀이","slug":"jungol-algorithm-1291","date":"2017-01-11T12:23:41.000Z","updated":"2017-01-12T01:29:53.000Z","comments":true,"path":"2017/01/11/jungol-algorithm-1291/","link":"","permalink":"http://futurecreator.github.io/2017/01/11/jungol-algorithm-1291/","excerpt":"","text":"실력키우기 &gt; 도형만들기 &gt; 구구단 (1291) 문제 클릭간단한 구구단 문제입니다. 하지만 두 수를 입력받아 그 사이의 단수를 순차적으로 정렬해서 출력해야하는 문제입니다. 입력받는 두 수에 따라서 순서가 달라질 수 있습니다. 예를 들어 3과 5가 입력되는 경우는 3, 4, 5단이 출력되어야 하고, 5와 3이 입력되는 경우는 5, 4, 3 단이 입력되어야 합니다. 따라서 입력되는 두 수의 크기를 비교해서 로직을 나눴습니다. 출력하는 폼은 어렵지 않습니다. 보통 구구단 출력 시 3 1 = 3, 3 2 = 6, … 이런 순으로 출력하는 대신에 3 1 = 3, 4 1 = 4, 5 * 1 = 5, … 순으로 j 가 아닌 i 순으로 출력하면 됩니다. 줄을 맞춰주는 부분에서 오답이 날 수 있는데, printf 에서 %2d 로 출력하시면 결과가 두 자리에 맞춰서 출력됩니다. 구구단에서는 제일 큰 숫자가 81이니까 두 자리면 충분하겠죠. 1System.out.printf(\"%d * %d = %2d \", j, i, j * i); 4, 8이 12와 맞춰서 출력되는 것을 보실 수 있습니다.12344 * 1 = 4 3 * 1 = 34 * 2 = 8 3 * 2 = 64 * 3 = 12 3 * 3 = 9... 전체 소스입니다. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/************************************************************** Problem: 1291 User: future_creator Language: Java Result: Success Time:195 ms Memory:10300 kb****************************************************************/import java.util.Scanner;public class Main &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); while (true) &#123; int n = sc.nextInt(); int e = sc.nextInt(); if (n &gt; 9 || e &gt; 9 || n &lt; 2 || e &lt; 2) &#123; System.out.println(\"INPUT ERROR!\"); continue; &#125; if (n &gt; e) &#123; for (int i = 1; i &lt; 10; i++) &#123; for (int j = n; j &gt;= e; j--) &#123; System.out.printf(\"%d * %d = %2d \", j, i, j * i); &#125; System.out.println(); &#125; &#125; else &#123; for (int i = 1; i &lt; 10; i++) &#123; for (int j = n; j &lt;= e; j++) &#123; System.out.printf(\"%d * %d = %2d \", j, i, j * i); &#125; System.out.println(); &#125; &#125; break; &#125; &#125;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://futurecreator.github.io/categories/Algorithm/"},{"name":"Jungol","slug":"Algorithm/Jungol","permalink":"http://futurecreator.github.io/categories/Algorithm/Jungol/"}],"tags":[{"name":"basic","slug":"basic","permalink":"http://futurecreator.github.io/tags/basic/"},{"name":"algorithm","slug":"algorithm","permalink":"http://futurecreator.github.io/tags/algorithm/"}]},{"title":"정올(JUNGOL) 파스칼 삼각형(2071) 알고리즘 기초 문제 풀이","slug":"jungol-algorithm-2071","date":"2017-01-11T12:02:45.000Z","updated":"2017-01-11T12:21:38.000Z","comments":true,"path":"2017/01/11/jungol-algorithm-2071/","link":"","permalink":"http://futurecreator.github.io/2017/01/11/jungol-algorithm-2071/","excerpt":"","text":"실력키우기 &gt; 도형만들기 &gt; 파스칼 삼각형 (2071) 문제 클릭 파스칼 삼각형은 정점부터 변을 따라 1로 채워져있고, 위에 있는 두 수를 더해서 아래 칸에 채워넣는 방식으로 이루어져 있습니다. 같은 파스칼 삼각형이지만 종류에 따라 모양을 다르게 해서 출력하고 있습니다. 모양은 다르지만 출력하는 요령은 똑같습니다. 처음 꼭지점과 그 아래 두 개의 1은 고정입니다. 그리고 다음 라인부터 위의 두 값을 더해서 출력하면 됩니다. 어떤 부분은 무조건 1로 넣을 것인가도 생각해봐야겠죠. 종류 2의 경우는 왼쪽 벽에 붙은 역삼각형 형태의 파스칼 삼각형을 만든 후에 공백을 출력해서 가운데쪽으로 정렬하면 됩니다. 복잡해 보이지만 오히려 다른 문제보다 쉽습니다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129/************************************************************** Problem: 2071 User: future_creator Language: Java Result: Success Time:243 ms Memory:10556 kb****************************************************************/import java.util.Scanner;public class Main &#123; static int[][] arr; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); int n = sc.nextInt(); int m = sc.nextInt(); arr = new int[n][n]; switch (m) &#123; case 1: arr[0][0] = 1; arr[1][0] = 1; arr[1][1] = 1; for (int i = 2; i &lt; n; i++) &#123; for (int j = 0; j &lt; i + 1; j++) &#123; if (i == j || j == 0) &#123; arr[i][j] = 1; &#125; else &#123; arr[i][j] = arr[i - 1][j - 1] + arr[i - 1][j]; &#125; &#125; &#125; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; i + 1; j++) &#123; System.out.print(arr[i][j] + \" \"); &#125; System.out.println(); &#125; break; case 2: arr[n - 1][0] = 1; arr[n - 2][0] = 1; arr[n - 2][1] = 1; for (int i = n - 3; i &gt; -1; i--) &#123; for (int j = 0; j &lt; n - i; j++) &#123; if (i + j == n - 1 || j == 0) &#123; arr[i][j] = 1; &#125; else &#123; arr[i][j] = arr[i + 1][j - 1] + arr[i + 1][j]; &#125; &#125; &#125; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; i; j++) &#123; System.out.print(\" \"); &#125; for (int j = 0; j &lt; n - i; j++) &#123; System.out.print(arr[i][j] + \" \"); &#125; System.out.println(); &#125; break; case 3: arr[n - 1][n - 1] = 1; arr[n - 1][n - 2] = 1; arr[n - 2][n - 2] = 1; int k = 1; for (int i = n - 2; i &gt; -1; i--) &#123; for (int j = i; j &lt; n; j++) &#123; if (i == j || j == n - 1) &#123; arr[j][i] = 1; &#125; else &#123; arr[j][i] = arr[j][i + 1] + arr[j + 1][i + 1]; &#125; &#125; &#125; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; i + 1; j++) &#123; System.out.print(arr[i][j] + \" \"); &#125; System.out.println(); &#125; break; default: break; &#125; &#125;&#125;class Point &#123; int x; int y; public Point(int x, int y) &#123; this.x = x; this.y = y; &#125; @Override public String toString() &#123; return \"Point [x=\" + x + \", y=\" + y + \"]\"; &#125;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://futurecreator.github.io/categories/Algorithm/"},{"name":"Jungol","slug":"Algorithm/Jungol","permalink":"http://futurecreator.github.io/categories/Algorithm/Jungol/"}],"tags":[{"name":"basic","slug":"basic","permalink":"http://futurecreator.github.io/tags/basic/"},{"name":"algorithm","slug":"algorithm","permalink":"http://futurecreator.github.io/tags/algorithm/"}]},{"title":"정올(JUNGOL) 문자삼각형2(1339) 알고리즘 기초 문제 풀이","slug":"jungol-algorithm-1339","date":"2017-01-11T11:33:19.000Z","updated":"2017-01-11T12:00:17.000Z","comments":true,"path":"2017/01/11/jungol-algorithm-1339/","link":"","permalink":"http://futurecreator.github.io/2017/01/11/jungol-algorithm-1339/","excerpt":"","text":"실력키우기 &gt; 도형만들기 &gt; 문자삼각형2(1339) 문제 클릭 문자삼각형 두번째 문제입니다. 이번 문제 또한 출력 방향이 정해져있네요. 위에서 아래로 순서대로 출력하면 됩니다. 다만 시작점이 애매한데, n 의 중간 부분입니다. n 은 홀수이므로 (n + 1) / 2 를 이용해 구할 수 있습니다. 가운데에서 시작해서 한칸씩 옆으로 이동하면서 출력 횟수를 1, 3, 5 이렇게 늘려서 출력합니다. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091/************************************************************** Problem: 1339 User: future_creator Language: Java Result: Success Time:314 ms Memory:10992 kb****************************************************************/import java.util.Scanner;public class Main &#123; static int[][] arr; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); int n = sc.nextInt(); int size = (n + 1) / 2; arr = new int[n][size]; if (n &gt; 99 || n &lt; 1 || n % 2 == 0) &#123; System.out.println(\"INPUT ERROR\"); System.exit(0); &#125; Point here = new Point(size - 1, size - 1); int k = 1; int kk = 1; while (true) &#123; // 반복출력 for (int i = 0; i &lt; kk; i++) &#123; arr[here.x][here.y] = k++; here.x += 1; &#125; kk = kk + 2; // 이동 if (here.y - 1 &gt; -1) &#123; here.y--; here.x = here.y; &#125; else &#123; break; &#125; &#125; // 알파벳으로 변경 for (int i = 0; i &lt; arr.length; i++) &#123; for (int j = 0; j &lt; arr[i].length; j++) &#123; if (arr[i][j] != 0) &#123; while (arr[i][j] &gt; 26) &#123; arr[i][j] -= 26; &#125; arr[i][j] += 64; &#125; &#125; &#125; for (int i = 0; i &lt; arr.length; i++) &#123; for (int j = 0; j &lt; arr[i].length; j++) &#123; if (arr[i][j] != 0) &#123; System.out.printf(\"%c \", arr[i][j]); &#125; &#125; System.out.println(); &#125; &#125;&#125;class Point &#123; int x; int y; public Point(int x, int y) &#123; this.x = x; this.y = y; &#125; @Override public String toString() &#123; return \"Point [x=\" + x + \", y=\" + y + \"]\"; &#125;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://futurecreator.github.io/categories/Algorithm/"},{"name":"Jungol","slug":"Algorithm/Jungol","permalink":"http://futurecreator.github.io/categories/Algorithm/Jungol/"}],"tags":[{"name":"basic","slug":"basic","permalink":"http://futurecreator.github.io/tags/basic/"},{"name":"algorithm","slug":"algorithm","permalink":"http://futurecreator.github.io/tags/algorithm/"}]},{"title":"정올(JUNGOL) 문자삼각형1(1338) 알고리즘 기초 문제 풀이","slug":"jungol-algorithm-1338","date":"2017-01-11T11:07:42.000Z","updated":"2017-01-11T11:30:06.000Z","comments":true,"path":"2017/01/11/jungol-algorithm-1338/","link":"","permalink":"http://futurecreator.github.io/2017/01/11/jungol-algorithm-1338/","excerpt":"","text":"실력키우기 &gt; 도형만들기 &gt; 문자삼각형1(1338) 문제 클릭 이전 문제들과 비슷합니다. 다만 삼각형 내에 문자를 채우는 순서와 삼각형의 형태의 차이가 있습니다. 일단 이차원 배열을 선언하고 오른쪽 상단부터 Point 클래스를 이용해 위치를 지정합니다. x, y 좌표를 함께 저장하기 위해 Point 클래스를 만들었습니다. 순서는 왼쪽 아래로 지정되어 있습니다. dir 변수를 이용해 방향을 틀지 않아도 되겠군요. 방향이 고정이니까 왼쪽 아래에서 이동이 불가능한 경우만 다음 지점으로 이동할 수 있도록 해주면 무리없이 풀 수 있는 문제입니다. 숫자를 저장한 후에 문자로 출력하기 위해 마지막에 for 문으로 64를 더했습니다. ‘A’ 는 숫자 65와 같은 값이고 표현만 다르게 한 것이기 때문입니다. 그래서 printf 를 이용해 “%c” 형태로 출력하면 ‘A’ 가 출력됩니다. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283/************************************************************** Problem: 1338 User: future_creator Language: Java Result: Success Time:572 ms Memory:18792 kb****************************************************************/import java.util.Scanner;public class Main &#123; static int[][] arr; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); int n = sc.nextInt(); arr = new int[n][n]; Point here = new Point(0, n - 1); int k = 1; arr[0][n - 1] = k++; int tmpX = 0; int tmpY = 0; while (here.x != n - 1 || here.y != n - 1) &#123; if (here.x + 1 &lt; n &amp;&amp; here.y - 1 &gt; -1) &#123; here.x += 1; here.y -= 1; arr[here.x][here.y] = k++; &#125; else &#123; tmpX = here.x; tmpY = here.y; here.x = tmpY + 1; here.y = tmpX; arr[here.x][here.y] = k++; &#125; &#125; int tmp = 0; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; tmp = arr[i][j]; if (tmp != 0) &#123; while (tmp &gt; 26) &#123; tmp -= 26; &#125; arr[i][j] = tmp + 64; &#125; &#125; &#125; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; if (arr[i][j] == 0) &#123; System.out.print(\" \"); &#125; else &#123; System.out.printf(\"%c \", arr[i][j]); &#125; &#125; System.out.println(); &#125; &#125;&#125;class Point &#123; int x; int y; public Point(int x, int y) &#123; this.x = x; this.y = y; &#125; @Override public String toString() &#123; return \"Point [x=\" + x + \", y=\" + y + \"]\"; &#125;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://futurecreator.github.io/categories/Algorithm/"},{"name":"Jungol","slug":"Algorithm/Jungol","permalink":"http://futurecreator.github.io/categories/Algorithm/Jungol/"}],"tags":[{"name":"basic","slug":"basic","permalink":"http://futurecreator.github.io/tags/basic/"},{"name":"algorithm","slug":"algorithm","permalink":"http://futurecreator.github.io/tags/algorithm/"}]},{"title":"정올(JUNGOL) 달팽이삼각형(1337) 알고리즘 기초 문제 풀이","slug":"jungol-algorithm-1337","date":"2017-01-11T04:15:52.000Z","updated":"2017-01-11T04:26:22.000Z","comments":true,"path":"2017/01/11/jungol-algorithm-1337/","link":"","permalink":"http://futurecreator.github.io/2017/01/11/jungol-algorithm-1337/","excerpt":"","text":"실력키우기 &gt; 도형만들기 &gt; 달팽이삼각형 (1337) 문제 클릭123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123/************************************************************** Problem: 1337 User: future_creator Language: Java Result: Success Time:294 ms Memory:11300 kb****************************************************************/import java.util.Arrays;import java.util.Scanner;public class Main &#123; static int[][] arr; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); int n = sc.nextInt(); arr = new int[n][n]; for (int i = 0; i &lt; n; i++) &#123; Arrays.fill(arr[i], -1); &#125; int dir = 1; Point[] move = new Point[3]; move[1] = new Point(1, 1); move[2] = new Point(0, -1); move[0] = new Point(-1, 0); Point here = new Point(0, 0); arr[0][0] = 0; int dirs = 0; int k = 1; for (int i = 0; i &lt; 100000; i++) &#123; dirs = dir % 3; switch (dirs) &#123; case 1: // 대각선 if (here.x + move[dirs].x &lt; n &amp;&amp; here.y + move[dirs].y &lt; n &amp;&amp; arr[here.x + move[dirs].x][here.y + move[dirs].y] == -1) &#123; here.x += move[dirs].x; here.y += move[dirs].y; if (k &gt; 9) &#123; k = 0; &#125; arr[here.x][here.y] = k++; &#125; else &#123; dir++; &#125; break; case 2: // 오른쪽 - 왼쪽 if (here.y + move[dirs].y &gt; -1 &amp;&amp; arr[here.x + move[dirs].x][here.y + move[dirs].y] == -1) &#123; here.x += move[dirs].x; here.y += move[dirs].y; if (k &gt; 9) &#123; k = 0; &#125; arr[here.x][here.y] = k++; &#125; else &#123; dir++; &#125; break; case 0: // 아래 -&gt; 위 if (here.x + move[dirs].x &gt; -1 &amp;&amp; arr[here.x + move[dirs].x][here.y + move[dirs].y] == -1) &#123; here.x += move[dirs].x; here.y += move[dirs].y; if (k &gt; 9) &#123; k = 0; &#125; arr[here.x][here.y] = k++; &#125; else &#123; dir++; &#125; break; default: break; &#125; &#125; int tmp = 0; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; tmp = arr[i][j]; if (tmp != -1) &#123; System.out.print(tmp + \" \"); &#125; &#125; System.out.println(); &#125; &#125;&#125;class Point &#123; int x; int y; public Point(int x, int y) &#123; this.x = x; this.y = y; &#125; @Override public String toString() &#123; return \"Point [x=\" + x + \", y=\" + y + \"]\"; &#125;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://futurecreator.github.io/categories/Algorithm/"},{"name":"Jungol","slug":"Algorithm/Jungol","permalink":"http://futurecreator.github.io/categories/Algorithm/Jungol/"}],"tags":[{"name":"basic","slug":"basic","permalink":"http://futurecreator.github.io/tags/basic/"},{"name":"algorithm","slug":"algorithm","permalink":"http://futurecreator.github.io/tags/algorithm/"}]},{"title":"정올(JUNGOL) 숫자삼각형(1641) 알고리즘 기초 문제 풀이","slug":"jungol-algorithm-1641","date":"2017-01-11T03:54:11.000Z","updated":"2017-01-11T04:15:19.000Z","comments":true,"path":"2017/01/11/jungol-algorithm-1641/","link":"","permalink":"http://futurecreator.github.io/2017/01/11/jungol-algorithm-1641/","excerpt":"","text":"실력키우기 &gt; 도형만들기 &gt; 숫자삼각형 (1641) 문제 클릭 정올 사이트의 실력키우기 메뉴의 도형만들기 챕터가 총 20개의 문제로 이루어져 있는데 그 중 14번째 문제입니다. 이제 거의 끝이 보이네요. 비슷비슷하면서 조금씩 다른 문제들로, 기존 문제들을 푸셨다면 어렵지 않게 푸실 수 있는 문제입니다. 종류 1의 경우, 숫자를 삼각형 형태로 출력합니다. 어렵진 않지만 짝수번째 행에서는 출력 순서가 오른쪽에서 왼쪽으로, 기존과 반대입니다. i 는 행 번호에 관련되어있고, j 는 숫자의 출력 횟수에 관련이 있습니다. 즉, 삼각형 형태로 각 행마다 점점 늘어가는 형태는 홀수번째 행이나 짝수번째 행이나 같습니다만 출력하는 숫자만 역순이면 되겠군요. 한 행에 출력되어야 할 마지막 숫자를 만들어놓고 하나씩 줄여가면서 출력합니다. 종류 2의 경우, 공백과 숫자가 출력하는 부분을 나눠서 생각해보겠습니다. 공백은 점차 늘어가고 있습니다. 숫자는 홀수의 형태로 줄어가고 있습니다. 밑에서부터 보면 1부터 시작해서 홀수 형태로 늘어가고 있습니다. 숫자의 값은 0 부터 n-1 까지 입니다. 이건 i 를 출력하면 되겠군요. 종류 3의 경우, n 의 반만큼만 출력을 하고 있습니다. 그리고 숫자의 내용은 j + 1 로 열번호를 출력하고 있네요. 출력하는 횟수는 가운데를 기준으로 위쪽은 점차 늘어나고, 아래쪽에서는 줄어들고 있습니다. 기존 문제만 푸실 수 있으면 얼마든지 풀 수 있는 문제입니다. 주어진 입력 범위를 벗어나는 경우 “INPUT ERROR!” 를 출력하고 프로그램을 종료합니다. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192/************************************************************** Problem: 1641 User: future_creator Language: Java Result: Success Time:226 ms Memory:10668 kb****************************************************************/import java.util.Scanner;public class Main &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); int n = sc.nextInt(); int m = sc.nextInt(); int size = (n + 1) / 2; if (n % 2 == 0 || n &lt; 1 || n &gt; 99 || m &gt; 3 || m &lt; 1) &#123; System.out.println(\"INPUT ERROR!\"); System.exit(0); &#125; switch (m) &#123; case 1: int k = 1; int rk = 0; for (int i = 0; i &lt; n; i++) &#123; if (i % 2 == 0) &#123; for (int j = 0; j &lt; i + 1; j++) &#123; System.out.print(k++ + \" \"); &#125; &#125; else &#123; rk = k + i; k = k + i + 1; for (int j = 0; j &lt; i + 1; j++) &#123; System.out.print(rk-- + \" \"); &#125; &#125; System.out.println(); &#125; break; case 2: for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; i; j++) &#123; System.out.print(\" \"); &#125; for (int j = 0; j &lt; 2 * (n - i) - 1; j++) &#123; System.out.print(i + \" \"); &#125; System.out.println(); &#125; break; case 3: for (int i = 0; i &lt; n; i++) &#123; if (i &lt; size) &#123; for (int j = 0; j &lt; i + 1; j++) &#123; System.out.print(j + 1 + \" \"); &#125; &#125; else &#123; for (int j = 0; j &lt; n - i; j++) &#123; System.out.print(j + 1 + \" \"); &#125; &#125; System.out.println(); &#125; break; default: break; &#125; &#125;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://futurecreator.github.io/categories/Algorithm/"},{"name":"Jungol","slug":"Algorithm/Jungol","permalink":"http://futurecreator.github.io/categories/Algorithm/Jungol/"}],"tags":[{"name":"basic","slug":"basic","permalink":"http://futurecreator.github.io/tags/basic/"},{"name":"algorithm","slug":"algorithm","permalink":"http://futurecreator.github.io/tags/algorithm/"}]},{"title":"정올(JUNGOL) 별삼각형3(1329) 알고리즘 기초 문제 풀이","slug":"jungol-algorithm-1329","date":"2017-01-11T03:44:25.000Z","updated":"2017-01-11T03:50:52.000Z","comments":true,"path":"2017/01/11/jungol-algorithm-1329/","link":"","permalink":"http://futurecreator.github.io/2017/01/11/jungol-algorithm-1329/","excerpt":"","text":"실력키우기 &gt; 도형만들기 &gt; 별삼각형3 (1329) 문제 클릭 모양이 특이해보이지만 이전 문제들을 쭉 풀어오셨다면 별 거 아니란 걸 아실겁니다. 이중 for 문을 이용해 별과 공백을 출력합니다. 즉, 공백을 출력하는 부분과 별을 출력하는 부분을 나눠서 보시면 되겠죠. 가운데를 기준으로 보면, 위쪽은 공백과 숫자가 함께 늘어납니다. 아래쪽은 공백과 별이 함께 줄어들고 있습니다. 다만 별은 1, 3, 5, 7 이런 식으로 홀수처럼 늘어나고 줄어드는 걸 보실 수 있습니다. i 는 행의 숫자와 관련이 있고, j 는 실제로 별 또는 공백을 출력하는 횟수와 관련이 있습니다. 전체적으로 i 는 n 번 반복이고, 해당 i 가 가운데를 기준으로 위, 아래로 나눠서 로직을 구현합니다. 공백을 먼저 출력하고 별을 출력하시면 되는데, 몇번 출력하는지 j 를 설정해서 구현하시면 되겠습니다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/************************************************************** Problem: 1329 User: future_creator Language: Java Result: Success Time:271 ms Memory:10628 kb****************************************************************/import java.util.Scanner;public class Main &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); int n = sc.nextInt(); if (n % 2 == 0 || n &gt; 100 || n &lt;= 0) &#123; System.out.println(\"INPUT ERROR!\"); System.exit(0); &#125; int size = (n + 1) / 2; for (int i = 0; i &lt; n; i++) &#123; if (i &lt; size) &#123; for (int j = 0; j &lt; i; j++) &#123; System.out.print(\" \"); &#125; for (int j = 0; j &lt; 2 * i + 1; j++) &#123; System.out.print(\"*\"); &#125; &#125; else &#123; for (int j = 0; j &lt; n - 1 - i; j++) &#123; System.out.print(\" \"); &#125; for (int j = 0; j &lt; 2 * (n - i) - 1; j++) &#123; System.out.print(\"*\"); &#125; &#125; System.out.println(); &#125; &#125;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://futurecreator.github.io/categories/Algorithm/"},{"name":"Jungol","slug":"Algorithm/Jungol","permalink":"http://futurecreator.github.io/categories/Algorithm/Jungol/"}],"tags":[{"name":"basic","slug":"basic","permalink":"http://futurecreator.github.io/tags/basic/"},{"name":"algorithm","slug":"algorithm","permalink":"http://futurecreator.github.io/tags/algorithm/"}]},{"title":"정올(JUNGOL) 별삼각형2(1719) 알고리즘 기초 문제 풀이","slug":"jungol-algorithm-1719","date":"2017-01-11T03:19:21.000Z","updated":"2017-01-11T03:41:58.000Z","comments":true,"path":"2017/01/11/jungol-algorithm-1719/","link":"","permalink":"http://futurecreator.github.io/2017/01/11/jungol-algorithm-1719/","excerpt":"","text":"실력키우기 &gt; 도형만들기 &gt; 별삼각형2 (1719) 문제 클릭 이전 별삼각형1 문제 에서 종류가 늘었네요. 별을 찍어야하는 부분과 공백을 출력해야 하는 부분으로 나눠집니다. 종류 1의 경우는 별이 증가하는 부분과 줄어드는 부분으로 나눠집니다. 이전 문제에서 종류 1과 종류 2를 합쳐놓은 형상이군요. 행에 따라서 if 문으로 분기해서 처리하시면 되겠습니다. 종류 2는 종류 1과 비슷하지만 정렬이 우측으로 되어있습니다. 즉, 왼쪽에 공백을 출력하고 있습니다. 가운데를 기준으로 보자면, 위쪽은 공백이 점차 줄어들고, 별의 개수는 늘어납니다. 그리고 아래쪽은 공백은 늘어나고, 별의 개수는 줄어들고 있습니다. 모두 i 를 이용해서 구현할 수 있는 부분입니다. 종류 3의 경우는 가운데를 기준으로, 위쪽은 공백이 늘어나고 별의 개수는 n 에서부터 홀수개로 줄어드는 형태입니다. 또한 아래쪽은 공백은 줄어들고, 별의 개수는 1개에서부터 3, 5 순으로 홀수개로 늘어나고 있습니다. 이전 문제들을 푸셨다면 아시겠지만, i 는 행 번호를 의미하고, j 는 별 (또는 공백)의 횟수를 의미합니다. 몇번 반복해서 별을 출력할 것이냐는 의미죠. 이 부분에 유의해서 생각해보시면 되겠습니다. 종류 4의 경우는 모양은 특이하지만 그리 어렵지 않습니다. 가운데를 기준으로 위쪽을 보면 공백은 늘어나고 개수는 줄어들고 있습니다. 그런데 갯수가 5개가 아닌 3개만 찍혀있죠. n 이 홀수이기 때문에 (n + 1) / 2 를 이용하면 구할 수 있는 부분입니다. 가운데 아래쪽은 (n + 1) / 2 부분부터 별의 갯수를 늘려가며 출력하는 간단한 부분입니다. 그리고 input 이 조건에 만족하지 않을 경우에는 “INPUT ERROR!” 를 출력하도록 되어있습니다. System.exit() 메서드를 이용해서 구현 가능합니다. 1234if (n &gt; 100 || n &lt; 1 || n % 2 == 0 || m &gt; 4 || m &lt; 1) &#123; System.out.println(\"INPUT ERROR!\"); System.exit(0);&#125; 전체 소스입니다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133/************************************************************** Problem: 1719 User: future_creator Language: Java Result: Success Time:199 ms Memory:10624 kb****************************************************************/import java.util.Scanner;public class Main &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); int n = sc.nextInt(); int m = sc.nextInt(); int size = (n + 1) / 2; if (n &gt; 100 || n &lt; 1 || n % 2 == 0 || m &gt; 4 || m &lt; 1) &#123; System.out.println(\"INPUT ERROR!\"); System.exit(0); &#125; switch (m) &#123; case 1: for (int i = 0; i &lt; n; i++) &#123; if (i &lt; size) &#123; for (int j = 0; j &lt; i + 1; j++) &#123; System.out.print(\"*\"); &#125; System.out.println(); &#125; else &#123; for (int j = 0; j &lt; n - i; j++) &#123; System.out.print(\"*\"); &#125; System.out.println(); &#125; &#125; break; case 2: for (int i = 0; i &lt; n; i++) &#123; if (i &lt; size) &#123; for (int j = 0; j &lt; size - i - 1; j++) &#123; System.out.print(\" \"); &#125; for (int j = 0; j &lt; i + 1; j++) &#123; System.out.print(\"*\"); &#125; &#125; else &#123; for (int j = size - 1; j &lt; i; j++) &#123; System.out.print(\" \"); &#125; for (int j = 0; j &lt; n - i; j++) &#123; System.out.print(\"*\"); &#125; &#125; System.out.println(); &#125; break; case 3: for (int i = 0; i &lt; n; i++) &#123; if (i &lt; size) &#123; for (int j = 0; j &lt; i; j++) &#123; System.out.print(\" \"); &#125; for (int j = 0; j &lt; n - 2 * i; j++) &#123; System.out.print(\"*\"); &#125; &#125; else &#123; for (int j = 0; j &lt; n - i - 1; j++) &#123; System.out.print(\" \"); &#125; for (int j = 0; j &lt; n - (n - i - 1) * 2; j++) &#123; System.out.print(\"*\"); &#125; &#125; System.out.println(); &#125; break; case 4: for (int i = 0; i &lt; n; i++) &#123; if (i &lt; size) &#123; for (int j = 0; j &lt; i; j++) &#123; System.out.print(\" \"); &#125; for (int j = 0; j &lt; size - i; j++) &#123; System.out.print(\"*\"); &#125; &#125; else &#123; for (int j = 0; j &lt; size - 1; j++) &#123; System.out.print(\" \"); &#125; for (int j = 0; j &lt; i + 2 - size; j++) &#123; // 계산으로 나온 식 System.out.print(\"*\"); &#125; &#125; System.out.println(); &#125; break; default: break; &#125; &#125;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://futurecreator.github.io/categories/Algorithm/"},{"name":"Jungol","slug":"Algorithm/Jungol","permalink":"http://futurecreator.github.io/categories/Algorithm/Jungol/"}],"tags":[{"name":"basic","slug":"basic","permalink":"http://futurecreator.github.io/tags/basic/"},{"name":"algorithm","slug":"algorithm","permalink":"http://futurecreator.github.io/tags/algorithm/"}]},{"title":"정올(JUNGOL) 별삼각형1(1523) 알고리즘 기초 문제 풀이","slug":"jungol-algorithm-1523","date":"2017-01-11T02:22:12.000Z","updated":"2017-01-11T03:16:05.000Z","comments":true,"path":"2017/01/11/jungol-algorithm-1523/","link":"","permalink":"http://futurecreator.github.io/2017/01/11/jungol-algorithm-1523/","excerpt":"","text":"실력키우기 &gt; 도형만들기 &gt; 별삼각형1 (1523) 문제 클릭 삼각형의 크기 n 을 입력받고, 종류 m 을 받아서 종류에 해당하는 형태로 출력하는 문제입니다. 이중 for 문을 이용해서 출력하면 되겠죠. 여기서 i 는 행(row) 인덱스를 의미하고, j 는 ‘별을 몇번 찍을 것인가’를 결정짓는 요인입니다. 종류 1의 경우, 행이 증가함에 따라 별을 출력하는 횟수도 함께 증가합니다. i 를 이용해서 j 를 구성하면 됩니다.종류 2의 경우, 역순으로 행이 증가함에 따라 별을 출력하는 횟수가 줄어듭니다. 이 또한 i 를 이용해서 구성하면 되겠습니다.종류 3의 경우, 행별로 별이 2개씩 증가합니다. 1, 3, 5, 7 순으로 출력이 됩니다. 이는 2 * n + 1 이라는 수식으로 표현할 수 있고 이를 이용해서 반복문을 구성하면 되겠습니다. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768/************************************************************** Problem: 1523 User: future_creator Language: Java Result: Success Time:238 ms Memory:10708 kb****************************************************************/import java.util.Scanner;public class Main &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); int n = sc.nextInt(); int m = sc.nextInt(); if (n &gt; 100 || n &lt; 1 || m &lt; 1 || m &gt; 3) &#123; System.out.println(\"INPUT ERROR!\"); System.exit(0); &#125; switch (m) &#123; case 1: // 순차적 for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; i + 1; j++) &#123; System.out.print(\"*\"); &#125; System.out.println(); &#125; break; case 2: // 역순 for (int i = 0; i &lt; n; i++) &#123; for (int j = n - i; j &gt; 0; j--) &#123; System.out.print(\"*\"); &#125; System.out.println(); &#125; break; case 3: // 정삼각형 for (int i = 0; i &lt; n; i++) &#123; for (int j = n - 1 - i; j &gt; 0; j--) &#123; System.out.print(\" \"); &#125; for (int j = 0; j &lt; 2 * i + 1; j++) &#123; System.out.print(\"*\"); &#125; System.out.println(); &#125; break; default: break; &#125; &#125;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://futurecreator.github.io/categories/Algorithm/"},{"name":"Jungol","slug":"Algorithm/Jungol","permalink":"http://futurecreator.github.io/categories/Algorithm/Jungol/"}],"tags":[{"name":"basic","slug":"basic","permalink":"http://futurecreator.github.io/tags/basic/"},{"name":"algorithm","slug":"algorithm","permalink":"http://futurecreator.github.io/tags/algorithm/"}]},{"title":"정올(JUNGOL) 마방진(2074) 알고리즘 기초 문제 풀이","slug":"jungol-algorithm-2074","date":"2017-01-11T01:33:13.000Z","updated":"2017-01-11T02:17:28.000Z","comments":true,"path":"2017/01/11/jungol-algorithm-2074/","link":"","permalink":"http://futurecreator.github.io/2017/01/11/jungol-algorithm-2074/","excerpt":"","text":"실력키우기 &gt; 도형만들기 &gt; 마방진 (2074) 문제 클릭마방진을 채우는 문제입니다. 마방진이란, 가로, 세로, 대각선 합이 같도록 1부터 숫자를 한 번씩만 써서 채운 정사각형입니다. 마방진을 만드는 방법은 문제에서 주어져있고, 해당 규칙을 따라 동작하도록 작성하기만 하면 됩니다. 첫 번째 숫자인 1을 넣는 위치는 첫 번째 행 가운데이다. 숫자가 N의 배수이면 바로 아래의 행으로 이동하여 다음의 수를 넣고 그렇지 않으면 왼쪽 위로 이동하여 다음의 숫자를 넣는다. 만약 행이 첫 번째를 벗어나면 마지막 행으로 이동하고, 열이 첫 번째를 벗어나면 마지막 열로 이동한다. 복잡해보이지만 오히려 다른 문제보다 쉽습니다. 이동 방향이 N 의 배수인 경우 아래쪽, 나머지는 왼쪽 대각선 위로 정해져있고, 이동할 수 없는 경우만 반대편으로 이동하도록 제약조건 걸어주시면 됩니다. 숫자가 N 이 되면 모두 채워진 것이므로, 해당 조건 하에 while 문을 돌면서 숫자를 채워나갑니다. 역시나 이번 문제에서도 Point 클래스를 이용해 x, y 좌표를 한꺼번에 저장했습니다. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879/************************************************************** Problem: 2074 User: future_creator Language: Java Result: Success Time:285 ms Memory:11368 kb****************************************************************/import java.util.Scanner;public class Main &#123; static int[][] arr; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); int n = sc.nextInt(); arr = new int[n][n]; int size = n * n + 1; // 시작점 Point here = new Point(0, (int) n / 2); arr[here.x][here.y] = 1; int k = 2; // 점 이동 // 종료조건 while (k &lt; size) &#123; if ((k - 1) % n == 0) &#123; here.x++; arr[here.x][here.y] = k++; &#125; else &#123; if (here.y - 1 &lt; 0) &#123; here.y = n - 1; &#125; else &#123; here.y--; &#125; if (here.x - 1 &lt; 0) &#123; // 반대편 쪽으로 here.x = n - 1; &#125; else &#123; here.x--; &#125; arr[here.x][here.y] = k++; &#125; &#125; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; System.out.print(arr[i][j] + \" \"); &#125; System.out.println(); &#125; &#125;&#125;class Point &#123; int x; int y; public Point(int x, int y) &#123; this.x = x; this.y = y; &#125; @Override public String toString() &#123; return \"Point [x=\" + x + \", y=\" + y + \"]\"; &#125;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://futurecreator.github.io/categories/Algorithm/"},{"name":"Jungol","slug":"Algorithm/Jungol","permalink":"http://futurecreator.github.io/categories/Algorithm/Jungol/"}],"tags":[{"name":"basic","slug":"basic","permalink":"http://futurecreator.github.io/tags/basic/"},{"name":"algorithm","slug":"algorithm","permalink":"http://futurecreator.github.io/tags/algorithm/"}]},{"title":"정올(JUNGOL) 대각선 지그재그(1495) 알고리즘 기초 문제 풀이","slug":"jungol-algorithm-1495","date":"2017-01-11T01:20:14.000Z","updated":"2017-01-11T02:17:46.000Z","comments":true,"path":"2017/01/11/jungol-algorithm-1495/","link":"","permalink":"http://futurecreator.github.io/2017/01/11/jungol-algorithm-1495/","excerpt":"","text":"실력키우기 &gt; 도형만들기 &gt; 대각선 지그재그 (1495) 문제 클릭숫자 n 을 입력받아 n x n 형태로 숫자를 출력합니다. 이 때 출력 순서에 대한 처리조건은 다음과 같습니다. (1) 가장 왼쪽 위의 좌표부터 차례로 숫자를 대입시킨다.(2) 대각선을 기준으로 계속 지그재그 모양으로 채워져야 하며 숫자는 1씩 증가하는 형태로 채워나가야 한다. 앞선 문제들과 처리 방식은 비슷합니다. 다만 채워가는 순서와 방향만 다를 뿐입니다. 먼저 Point 클래스를 이용해 x, y 좌표를 한꺼번에 저장하겠습니다. 그리고 int dir 변수를 이용해 4가지 방향에 대응하는 1, 2, 3, 0 숫자를 순서대로 사용하기 위해 %4 연산을 이용하겠습니다. 이번에는 Point 배열을 이용해 해당 방향에 이동할 값을 지정해보겠습니다. 12345678// 1 위 -&gt; 아래// 2 오른쪽위// 3 왼쪽 -&gt; 오른쪽// 0 왼쪽아래move[1] = new Point(1, 0);move[2] = new Point(-1, 1);move[3] = new Point(0, 1);move[0] = new Point(1, -1); dir%4 값을 이용해서 순서대로 나오는 1, 2, 3, 0 값으로 Point 배열 move 에 접근합니다. move[dir%4] 그러면 해당 방향에서 어떻게 움직일 것인가를 꺼내서 사용할 수 있습니다. ps) 보통 웹 프로그래밍에서 클래스는 캡슐화를 적용합니다만, 알고리즘 문제에서는 성능이 더 이슈이기 때문에 getter, setter 를 이용하지 않고 멤버변수에 바로 접근합니다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115/************************************************************** Problem: 1495 User: future_creator Language: Java Result: Success Time:264 ms Memory:10660 kb****************************************************************/import java.util.Scanner;public class Main &#123; static int[][] arr; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); int n = sc.nextInt(); arr = new int[n][n]; int dir = 1; Point[] move = new Point[4]; // 1 위 -&gt; 아래 // 2 오른쪽위 // 3 왼쪽 -&gt; 오른쪽 // 0 왼쪽아래 move[1] = new Point(1, 0); move[2] = new Point(-1, 1); move[3] = new Point(0, 1); move[0] = new Point(1, -1); Point here = new Point(0, 0); arr[0][0] = 1; int k = 2; int dir2 = 0; int size = n * n + 1; while (k != size) &#123; dir2 = dir % 4; switch (dir2) &#123; case 1: // 위 -&gt; 아 if (here.x + move[dir2].x &lt; n &amp;&amp; arr[here.x + move[dir2].x][here.y + move[dir2].y] == 0) &#123; here.x += move[dir2].x; here.y += move[dir2].y; arr[here.x][here.y] = k++; &#125; dir++; break; case 3: // 왼쪽 -&gt; 오른쪽 if (here.y + move[dir2].y &lt; n &amp;&amp; arr[here.x + move[dir2].x][here.y + move[dir2].y] == 0) &#123; here.x += move[dir2].x; here.y += move[dir2].y; arr[here.x][here.y] = k++; &#125; dir++; break; case 2: // 오른쪽 위 if (here.x + move[dir2].x &gt; -1 &amp;&amp; here.y + move[dir2].y &lt; n &amp;&amp; arr[here.x + move[dir2].x][here.y + move[dir2].y] == 0) &#123; here.x += move[dir2].x; here.y += move[dir2].y; arr[here.x][here.y] = k++; &#125; else &#123; dir++; &#125; break; case 0: // 왼쪽 아래 if (here.x + move[dir2].x &lt; n &amp;&amp; here.y + move[dir2].y &gt; -1 &amp;&amp; arr[here.x + move[dir2].x][here.y + move[dir2].y] == 0) &#123; here.x += move[dir2].x; here.y += move[dir2].y; arr[here.x][here.y] = k++; &#125; else &#123; dir++; &#125; break; default: break; &#125; &#125; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; System.out.print(arr[i][j] + \" \"); &#125; System.out.println(); &#125; &#125;&#125;class Point &#123; int x; int y; public Point(int x, int y) &#123; this.x = x; this.y = y; &#125; @Override public String toString() &#123; return \"Point [x=\" + x + \", y=\" + y + \"]\"; &#125;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://futurecreator.github.io/categories/Algorithm/"},{"name":"Jungol","slug":"Algorithm/Jungol","permalink":"http://futurecreator.github.io/categories/Algorithm/Jungol/"}],"tags":[{"name":"basic","slug":"basic","permalink":"http://futurecreator.github.io/tags/basic/"},{"name":"algorithm","slug":"algorithm","permalink":"http://futurecreator.github.io/tags/algorithm/"}]},{"title":"정올(JUNGOL) 문자마름모(1331) 알고리즘 기초 문제 풀이","slug":"jungol-algorithm-1331","date":"2017-01-11T00:35:29.000Z","updated":"2017-01-11T02:17:45.000Z","comments":true,"path":"2017/01/11/jungol-algorithm-1331/","link":"","permalink":"http://futurecreator.github.io/2017/01/11/jungol-algorithm-1331/","excerpt":"","text":"실력키우기 &gt; 도형만들기 &gt; 문자마름모 (1331) 문제 클릭이번 문제는 달팽이사각형 문제와 비슷하게 겉에서부터 안쪽으로 문자를 채워나가는 형태인데, 마름모 형태인 것이 다릅니다. 일단 마름모 전체가 들어갈 사이즈의 이차원 배열을 선언한 합니다. 이전 문제와 마찬가지로 Point 클래스를 하나 생성해서 현재 위치를 저장합니다. Point 클래스는 이차원 배열 내의 x 좌표와 y 좌표를 저장할 수 있는 int 변수 두개를 가지고 있습니다. 먼저 갈 수 없는 부분을 채워서 마름모 형태를 만들었습니다. 경계를 쳐놓은 다음에 그 안쪽을 순서대로 채워나갑니다. 방향은 왼쪽 아래, 오른쪽 아래, 오른쪽 위, 왼쪽 위 순으로 int dir 변수를 이용해서 순서대로 진행합니다. dir 값을 하나씩 올려가면서 %4 연산을 하면, dir % 4 값은 1, 2, 3, 0 중에 하나만 나오기 때문에 가능합니다. 이동 전에는 이동할 수 있는지 확인이 필요합니다. 문자 문제에서 계속 나오는 것처럼, ‘A’는 숫자 65와 같은 값이고, 출력 형태만 다를 뿐입니다. 그래서 처음에 빈 배열에 65를 더해놓고 0부터 시작해서 값을 더했습니다. 그리고 나서 나중에 printf 를 이용해 “%c” 형태로 출력하면 char 형태로 출력됩니다. A ~ Z 까지만 반복해서 출력해야 하기 때문에, 알파벳이 26글자이기 때문에 더할 값이 26보다 큰 경우에는 26보다 작게 만들어줍니다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165/************************************************************** Problem: 1331 User: future_creator Language: Java Result: Success Time:858 ms Memory:27028 kb****************************************************************/import java.util.Arrays;import java.util.Scanner;public class Main &#123; static int[][] arr; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); int n = sc.nextInt(); // 전체 사이즈 계산 int size = n * 2 - 1; arr = new int[size][size]; for (int i = 0; i &lt; arr.length; i++) &#123; Arrays.fill(arr[i], 64); &#125; int k = 2; // 갈 수 없는 지역을 만들어야 한다. int triSize = (int) size / 2; for (int i = 0; i &lt; triSize; i++) &#123; for (int j = 0; j &lt; triSize - i; j++) &#123; arr[i][j] = 0; &#125; for (int j = 0; j &lt; triSize - i; j++) &#123; arr[i][size - 1 - j] = 0; &#125; for (int j = 0; j &lt; i + 1; j++) &#123; arr[triSize + i + 1][j] = 0; &#125; for (int j = 0; j &lt; i + 1; j++) &#123; arr[triSize + i + 1][size - 1 - j] = 0; &#125; &#125; Point p = new Point(0, triSize); arr[p.x][p.y] = 65; // 방향 우선순위는 // dir1: 왼쪽 아래 x++ y-- // dir2: 오른쪽 아래 x++ y++ // dir3: 오른쪽 위 x-- y++ // dir4: 왼쪽 위 x-- y-- int dir = 1; boolean flag = true; while (flag) &#123; switch (dir % 4) &#123; case 1: if (p.x + 1 &lt; size &amp;&amp; p.y - 1 &gt; -1 &amp;&amp; arr[p.x + 1][p.y - 1] == 64) &#123; // 왼쪽 아래 갈 수 있으면 k = func1(k); arr[p.x + 1][p.y - 1] += k; k++; p.x++; p.y--; &#125; else &#123; dir++; &#125; break; case 2: if (p.x + 1 &lt; size &amp;&amp; p.y + 1 &lt; size &amp;&amp; arr[p.x + 1][p.y + 1] == 64) &#123; // 오른쪽 아래 갈 수 있으면 k = func1(k); arr[p.x + 1][p.y + 1] += k; k++; p.x++; p.y++; &#125; else &#123; dir++; &#125; break; case 3: if (p.x - 1 &gt; -1 &amp;&amp; p.y + 1 &lt; size &amp;&amp; arr[p.x - 1][p.y + 1] == 64) &#123; // 오른쪽 위 갈 수 있으면 k = func1(k); arr[p.x - 1][p.y + 1] += k; k++; p.x--; p.y++; &#125; else &#123; dir++; &#125; break; case 0: if (p.x - 1 &gt; -1 &amp;&amp; p.y - 1 &gt; 0 &amp;&amp; arr[p.x - 1][p.y - 1] == 64) &#123; // 왼쪽 위 갈 수 있으면 k = func1(k); arr[p.x - 1][p.y - 1] += k; k++; p.x--; p.y--; &#125; else &#123; // 갈 수 없을 때 왼쪽으로 이동 후 dir++ if (p.y - 1 &gt; -1 &amp;&amp; arr[p.x][p.y - 1] == 64) &#123; k = func1(k); arr[p.x][p.y - 1] += k; p.y--; k++; dir++; &#125; else &#123; // 왼쪽도 못가면 끝 flag = false; break; &#125; &#125; break; default: break; &#125; &#125; for (int i = 0; i &lt; size; i++) &#123; for (int j = 0; j &lt; size; j++) &#123; if (arr[i][j] == 0) &#123; System.out.print(\" \"); &#125; else &#123; System.out.printf(\"%c \", arr[i][j]); &#125; &#125; System.out.println(); &#125; &#125; static int func1(int n) &#123; if (n &gt; 26) &#123; return n - 26; &#125; return n; &#125;&#125;class Point &#123; int x; int y; public Point(int x, int y) &#123; super(); this.x = x; this.y = y; &#125; @Override public String toString() &#123; return \"Point [x=\" + x + \", y=\" + y + \"]\"; &#125;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://futurecreator.github.io/categories/Algorithm/"},{"name":"Jungol","slug":"Algorithm/Jungol","permalink":"http://futurecreator.github.io/categories/Algorithm/Jungol/"}],"tags":[{"name":"basic","slug":"basic","permalink":"http://futurecreator.github.io/tags/basic/"},{"name":"algorithm","slug":"algorithm","permalink":"http://futurecreator.github.io/tags/algorithm/"}]},{"title":"정올(JUNGOL) 달팽이사각형(1707) 알고리즘 기초 문제 풀이","slug":"jungol-algorithm-1707","date":"2017-01-11T00:12:26.000Z","updated":"2017-01-11T02:17:47.000Z","comments":true,"path":"2017/01/11/jungol-algorithm-1707/","link":"","permalink":"http://futurecreator.github.io/2017/01/11/jungol-algorithm-1707/","excerpt":"","text":"실력키우기 &gt; 도형만들기 &gt; 달팽이사각형 (1707) 문제 클릭n x n 의 사각형 안을 아래 → 왼쪽 → 위 → 오른쪽 순으로 채워나가는 문제입니다. 마치 달팽이 껍질 모양으로 채워나가게 됩니다. 일단 x, y 좌표를 한꺼번에 저장하기 위해서 Point 클래스를 이용했습니다. 그리고 순서가 정해져있기 때문에 그 순서대로 방향을 이동하기 위해서 int dir 을 이용했습니다. 왼쪽 -&gt; 오른쪽, 위 -&gt; 아래, 오른쪽 -&gt; 왼쪽, 아래 -&gt; 위 4가지 방향이 정해져 있는데, int 값을 %4 연산을 하면 dir 변수가 증가하면서 1, 2, 3, 0 값이 순서대로 나오게 됩니다. % 연산은 나머지 연산이기 때문이죠. 이를 이용해서 4가지 방향을 switch 로 잡아서 이동하면서 값을 저장하면 됩니다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128/************************************************************** Problem: 1707 User: future_creator Language: Java Result: Success Time:291 ms Memory:10532 kb****************************************************************/import java.util.Arrays;import java.util.Scanner;public class Main &#123; static int[][] arr; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); int n = sc.nextInt(); // 일단 %4로 방향 정하기 int dir = 1; arr = new int[n][n]; int size = n * n; for (int i = 0; i &lt; n; i++) &#123; Arrays.fill(arr[i], -1); &#125; // 현재 포인트 Point p = new Point(0, 0); int k = 1; while (k &lt;= size) &#123; switch (dir % 4) &#123; case 1: // 왼쪽 -&gt; 오른쪽 for (int i = 0; i &lt; n; i++) &#123; if (arr[p.x][p.y] == -1) &#123; arr[p.x][p.y] = k++; if (p.y &lt; n - 1 &amp;&amp; arr[p.x][p.y + 1] == -1) &#123; p.y++; &#125; &#125; &#125; p.x++; break; case 2: // 위 -&gt; 아래 for (int i = 0; i &lt; n; i++) &#123; if (arr[p.x][p.y] == -1) &#123; arr[p.x][p.y] = k++; if (p.x &lt; n - 1 &amp;&amp; arr[p.x + 1][p.y] == -1) &#123; p.x++; &#125; &#125; &#125; p.y--; break; case 3: // 오른쪽 -&gt; 왼쪽 for (int i = 0; i &lt; n; i++) &#123; if (arr[p.x][p.y] == -1) &#123; arr[p.x][p.y] = k++; if (p.y &gt; 0 &amp;&amp; arr[p.x][p.y - 1] == -1) &#123; p.y--; &#125; &#125; &#125; p.x--; break; case 0: // 아래 -&gt; 위 for (int i = 0; i &lt; n; i++) &#123; if (arr[p.x][p.y] == -1) &#123; arr[p.x][p.y] = k++; if (p.x &gt; 0 &amp;&amp; arr[p.x - 1][p.y] == -1) &#123; p.x--; &#125; &#125; &#125; p.y++; break; default: break; &#125; dir++; &#125; printArr2(); &#125; static void printArr() &#123; int n = arr.length; for (int i = 0; i &lt; n; i++) &#123; System.out.println(Arrays.toString(arr[i])); &#125; &#125; static void printArr2() &#123; int n = arr.length; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; System.out.print(arr[i][j] + \" \"); &#125; System.out.println(); &#125; &#125;&#125;class Point &#123; int x; int y; public Point(int x, int y) &#123; this.x = x; this.y = y; &#125; @Override public String toString() &#123; return \"Point [x=\" + x + \", y=\" + y + \"]\"; &#125;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://futurecreator.github.io/categories/Algorithm/"},{"name":"Jungol","slug":"Algorithm/Jungol","permalink":"http://futurecreator.github.io/categories/Algorithm/Jungol/"}],"tags":[{"name":"basic","slug":"basic","permalink":"http://futurecreator.github.io/tags/basic/"},{"name":"algorithm","slug":"algorithm","permalink":"http://futurecreator.github.io/tags/algorithm/"}]},{"title":"정올(JUNGOL) 문자사각형2(1314) 알고리즘 기초 문제 풀이","slug":"jungol-algorithm-1314","date":"2017-01-10T23:50:22.000Z","updated":"2017-01-11T02:17:45.000Z","comments":true,"path":"2017/01/11/jungol-algorithm-1314/","link":"","permalink":"http://futurecreator.github.io/2017/01/11/jungol-algorithm-1314/","excerpt":"","text":"실력키우기 &gt; 도형만들기 &gt; 문자사각형2 (1314) 문제 클릭이전 숫자사각형 문제들과 비슷한 문제입니다. n x n 형태의 배열로 문자를 출력하는데 순서는 세로방향입니다. 다만, 문자인 것만 다르죠. 이번에는 이차원 배열을 이용해서 풀어봤습니다. 이차원 배열에서 세로 방향 순서대로 접근하기 위해서는 for 문 안에서 arr[i][j] 형태가 아닌 arr[j][i] 로 접근하면 됩니다. 문자사각형1 문제와 마찬가지로 대문자 ‘A’는 숫자 65이고 표현만 다른 것이기 때문에, 문자를 출력하기 위해서는 숫자에 65를 더해서 문자 형태로 출력하면 됩니다. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/************************************************************** Problem: 1314 User: future_creator Language: Java Result: Success Time:580 ms Memory:13864 kb****************************************************************/import java.util.Scanner;public class Main &#123; static int[][] arr; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); int n = sc.nextInt(); arr = new int[n][n]; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; if (i % 2 == 0) &#123; arr[j][i] = func1(n * i + j) + 65; &#125; else &#123; arr[j][i] = func1(n * (i + 1) - (j + 1)) + 65; &#125; &#125; &#125; printArr(); &#125; static void printArr() &#123; for (int i = 0; i &lt; arr.length; i++) &#123; for (int j = 0; j &lt; arr[i].length; j++) &#123; System.out.printf(\"%c \", arr[i][j]); &#125; System.out.println(); &#125; &#125; static int func1(int n) &#123; while (n &gt; 25) &#123; n -= 26; &#125; return n; &#125;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://futurecreator.github.io/categories/Algorithm/"},{"name":"Jungol","slug":"Algorithm/Jungol","permalink":"http://futurecreator.github.io/categories/Algorithm/Jungol/"}],"tags":[{"name":"basic","slug":"basic","permalink":"http://futurecreator.github.io/tags/basic/"},{"name":"algorithm","slug":"algorithm","permalink":"http://futurecreator.github.io/tags/algorithm/"}]},{"title":"정올(JUNGOL) 문자사각형1(1307) 알고리즘 기초 문제 풀이","slug":"jungol-algorithm-1307","date":"2017-01-10T23:27:22.000Z","updated":"2017-01-11T02:17:44.000Z","comments":true,"path":"2017/01/11/jungol-algorithm-1307/","link":"","permalink":"http://futurecreator.github.io/2017/01/11/jungol-algorithm-1307/","excerpt":"","text":"실력키우기 &gt; 도형만들기 &gt; 문자사각형1 (1307) 문제 클릭이전까지의 문제와 마찬가지로 이차원 배열을 이용해 풀 수 있습니다. 문제에서 원하는 순서대로 for 문을 돌면서 숫자를 채워나가면 됩니다. 하지만 저는 배열 사용하지 않고 바로 출력해봤습니다. 그런데 이번에는 숫자가 아니라 문자 출력입니다. 하지만 굳이 char 배열을 사용할 필요가 없습니다. 왜냐하면 Java 에서 char 도 결국에는 숫자이고 출력형태에 따라 값이 다르게 보이는 것 뿐이기 때문입니다. 대문자 ‘A’ 는 숫자 65에 해당합니다. 따라서 0 부터 시작하는 값에 65를 더하고 printf 를 이용해 “%c” 로 출력하면 문자가 출력됩니다. 마지막으로 Z 이후에 다시 A 가 되어야합니다. 알파벳은 26 글자이기 때문에 26을 빼서 다시 A 로 만들어줍니다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445/************************************************************** Problem: 1307 User: future_creator Language: Java Result: Success Time:604 ms Memory:13040 kb****************************************************************/import java.util.Scanner;public class Main &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); int n = sc.nextInt(); int k = 0; for (int i = 0; i &lt; n; i++) &#123; k = n * n - i - 1; for (int j = 0; j &lt; n; j++) &#123; if (k &gt; 25) &#123; System.out.printf(\"%c \", func1(k) + 65); &#125; else &#123; System.out.printf(\"%c \", k + 65); &#125; k -= n; &#125; System.out.println(); &#125; &#125; static int func1(int num) &#123; while (num &gt; 25) &#123; num -= 26; &#125; return num; &#125;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://futurecreator.github.io/categories/Algorithm/"},{"name":"Jungol","slug":"Algorithm/Jungol","permalink":"http://futurecreator.github.io/categories/Algorithm/Jungol/"}],"tags":[{"name":"basic","slug":"basic","permalink":"http://futurecreator.github.io/tags/basic/"},{"name":"algorithm","slug":"algorithm","permalink":"http://futurecreator.github.io/tags/algorithm/"}]},{"title":"정올(JUNGOL) 숫자사각형4(2046) 알고리즘 기초 문제 풀이","slug":"jungol-algorithm-2046","date":"2017-01-10T23:13:41.000Z","updated":"2017-01-11T02:17:47.000Z","comments":true,"path":"2017/01/11/jungol-algorithm-2046/","link":"","permalink":"http://futurecreator.github.io/2017/01/11/jungol-algorithm-2046/","excerpt":"","text":"실력키우기 &gt; 도형만들기 &gt; 숫자사각형4 (2046) 문제 클릭숫자 n 을 입력받아 n x n 형태로 숫자를 출력하는 문제입니다. 종류 m 도 받아서 해당 종류에 맞는 형태로 출력하면 됩니다. 종류 1의 경우 그냥 i 값을 이용해 출력하면 되는 간단한 문제입니다. 종류 2의 경우는 홀수번째 행과 짝수번째 행의 차이만 있을 뿐 1 부터 n 까지 출력하는 내용은 같습니다. i 에 따라서 출력하는 순서만 바꿔주면 됩니다. 종류 3의 경우는 해당 i 에 배수 형태로 출력하면 됩니다. 크게 어렵지 않은 문제였습니다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778/************************************************************** Problem: 2046 User: future_creator Language: Java Result: Success Time:260 ms Memory:11272 kb****************************************************************/import java.util.Scanner;public class Main &#123; static int n; static int m; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); n = sc.nextInt(); m = sc.nextInt(); // 종류 switch (m) &#123; case 1: func1(); break; case 2: func2(); break; case 3: func3(); break; default: break; &#125; &#125; static void func1() &#123; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; System.out.print(i + 1 + \" \"); &#125; System.out.println(); &#125; &#125; static void func2() &#123; for (int i = 0; i &lt; n; i++) &#123; if (i % 2 == 0) &#123; for (int j = 0; j &lt; n; j++) &#123; System.out.print(j + 1 + \" \"); &#125; &#125; else &#123; for (int j = n; j &gt; 0; j--) &#123; System.out.print(j + \" \"); &#125; &#125; System.out.println(); &#125; &#125; static void func3() &#123; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt; n + 1; j++) &#123; System.out.print(j * i + \" \"); &#125; System.out.println(); &#125; &#125;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://futurecreator.github.io/categories/Algorithm/"},{"name":"Jungol","slug":"Algorithm/Jungol","permalink":"http://futurecreator.github.io/categories/Algorithm/Jungol/"}],"tags":[{"name":"basic","slug":"basic","permalink":"http://futurecreator.github.io/tags/basic/"},{"name":"algorithm","slug":"algorithm","permalink":"http://futurecreator.github.io/tags/algorithm/"}]},{"title":"정올(JUNGOL) 숫자사각형3(1304) 알고리즘 기초 문제 풀이","slug":"jungol-algorithm-1304","date":"2017-01-10T22:56:11.000Z","updated":"2017-01-11T02:17:42.000Z","comments":true,"path":"2017/01/11/jungol-algorithm-1304/","link":"","permalink":"http://futurecreator.github.io/2017/01/11/jungol-algorithm-1304/","excerpt":"","text":"실력키우기 &gt; 도형만들기 &gt; 숫자사각형3 (1304) 문제 클릭정사각형 한 변의 길이 n 을 입력받아 n x n 형태로 숫자를 출력하는 문제입니다. 출력 순서는 가로 방향이 아니라 세로 방향으로 출력합니다. 좀 더 쉽게 접근할 수 있는 방법은 이차원 배열을 선언 후에 세로 방향으로 숫자를 채워나간 후에 출력하면 됩니다. 저는 배열 없이 바로 출력하기 위해서 각 열에 사이즈 n 을 곱해서 숫자를 계산했습니다. 어렵지 않게 풀 수 있는 문제입니다. 123456789101112131415161718192021222324252627/************************************************************** Problem: 1304 User: future_creator Language: Java Result: Success Time:359 ms Memory:10824 kb****************************************************************/import java.util.Scanner;public class Main &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); int n = sc.nextInt(); for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; System.out.print(n * j + i + 1 + \" \"); &#125; System.out.println(); &#125; &#125;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://futurecreator.github.io/categories/Algorithm/"},{"name":"Jungol","slug":"Algorithm/Jungol","permalink":"http://futurecreator.github.io/categories/Algorithm/Jungol/"}],"tags":[{"name":"basic","slug":"basic","permalink":"http://futurecreator.github.io/tags/basic/"},{"name":"algorithm","slug":"algorithm","permalink":"http://futurecreator.github.io/tags/algorithm/"}]},{"title":"정올(JUNGOL) 숫자사각형2(1856) 알고리즘 기초 문제 풀이","slug":"jungol-algorithm-1856","date":"2017-01-10T13:13:06.000Z","updated":"2017-01-11T02:17:39.000Z","comments":true,"path":"2017/01/10/jungol-algorithm-1856/","link":"","permalink":"http://futurecreator.github.io/2017/01/10/jungol-algorithm-1856/","excerpt":"","text":"실력키우기 &gt; 도형만들기 &gt; 숫자사각형2 (1856) 문제 클릭두 수 n, m 을 입력받아 n x m 으로 순서대로 숫자를 출력하면 됩니다. 하지만 짝수번째 줄에서는 순서를 반대로 출력해야 합니다. for 문에서 if 문을 이용해 홀수번째 줄인지 짝수번째 줄인지를 확인하고, 짝수번째 줄일 때는 k 를 새로 계산해 하나씩 감소하면서 출력합니다. 바로 출력하기 위해서 이런 방법을 썼지만, 물론 이중배열을 선언해서 풀 수도 있습니다. 짝수번째 줄의 경우에는 배열 읽는 방향을 바꿔서 숫자를 차례대로 저장하면 됩니다. 12345678910111213141516171819202122232425262728293031323334353637/************************************************************** Problem: 1856 User: future_creator Language: Java Result: Success Time:248 ms Memory:10668 kb****************************************************************/import java.util.Scanner;public class Main &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); int n = sc.nextInt(); int m = sc.nextInt(); int k = 1; for (int i = 0; i &lt; n; i++) &#123; if (i % 2 == 0) &#123; k = i * m + 1; for (int j = 0; j &lt; m; j++) &#123; System.out.print(k++ + \" \"); &#125; &#125; else &#123; k = (i + 1) * m; for (int j = 0; j &lt; m; j++) &#123; System.out.print(k-- + \" \"); &#125; &#125; System.out.println(); &#125; &#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://futurecreator.github.io/categories/Algorithm/"},{"name":"Jungol","slug":"Algorithm/Jungol","permalink":"http://futurecreator.github.io/categories/Algorithm/Jungol/"}],"tags":[{"name":"basic","slug":"basic","permalink":"http://futurecreator.github.io/tags/basic/"},{"name":"algorithm","slug":"algorithm","permalink":"http://futurecreator.github.io/tags/algorithm/"}]},{"title":"정올(JUNGOL) 숫자사각형1(1303) 알고리즘 기초 문제 풀이","slug":"jungol-algorithm-1303","date":"2017-01-10T13:00:00.000Z","updated":"2017-01-11T02:09:46.000Z","comments":true,"path":"2017/01/10/jungol-algorithm-1303/","link":"","permalink":"http://futurecreator.github.io/2017/01/10/jungol-algorithm-1303/","excerpt":"","text":"실력키우기 &gt; 도형만들기 &gt; 숫자사각형1 (1303) 문제 클릭입력받은 두 숫자 n, m 으로 n x m 배열 형태로 출력하는 문제입니다. 이중 for 문을 이용해 간단하게 출력 가능합니다. 123456789101112131415161718192021222324252627282930/************************************************************** Problem: 1303 User: future_creator Language: Java Result: Success Time:254 ms Memory:10492 kb****************************************************************/import java.util.Scanner;public class Main &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); int n = sc.nextInt(); int m = sc.nextInt(); int k = 1; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; m; j++) &#123; System.out.print(k++ + \" \"); &#125; System.out.println(); &#125; &#125;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://futurecreator.github.io/categories/Algorithm/"},{"name":"Jungol","slug":"Algorithm/Jungol","permalink":"http://futurecreator.github.io/categories/Algorithm/Jungol/"}],"tags":[{"name":"basic","slug":"basic","permalink":"http://futurecreator.github.io/tags/basic/"},{"name":"algorithm","slug":"algorithm","permalink":"http://futurecreator.github.io/tags/algorithm/"}]},{"title":"프리라이팅에 적합한 글쓰기 앱 Flowstate (Mac OS X 추천앱)","slug":"flowstate-mac-osx-writing-app","date":"2016-07-03T01:49:13.000Z","updated":"2016-07-03T01:52:02.000Z","comments":true,"path":"2016/07/03/flowstate-mac-osx-writing-app/","link":"","permalink":"http://futurecreator.github.io/2016/07/03/flowstate-mac-osx-writing-app/","excerpt":"","text":"세상에서 가장 위험한 글쓰기 앱 글을 쓰는 데 있어 가장 어려운 일은 무엇일까요? 바로 글을 쓰기 시작하는 일 입니다. 한번 글을 쓰기 시작하면 어떻게 어떻게 쓰게 되지만, 아무것도 없는 백지 위에 무언가를 쓰기 시작한다는 행위는 쉬운 일이 아닙니다. 글쓰기 연습하는 방법 중에 프리라이팅 (Free Writing) 이라는 방법이 있습니다. 일정 시간을 정해놓고, 내 머리 속에 있는 생각들을 여과 없이, 망설임없이 써내려가는 방법입니다. 저는 이 방법을 굉장히 좋아합니다. 왜냐하면 글을 쓰는 연습도 될 뿐만 아니라 머리가 복잡하고 마음이 답답할 때 프리라이팅을 통해서 다 털어버리고 나면 마음이 후련해지더군요. 프리라이팅의 진짜 매력은 이런 게 아닐까 싶기도 합니다. Flowstate 는 프리라이팅을 연습할 때 딱맞는 앱입니다. 적다가 5초만 망설이게 되면 적었던 내용이 모두 사라지기 때문에 ‘세상에서 가장 위험한 글쓰기 앱’ 이라고 합니다만, 프리라이팅에는 최적화되어있죠. 무언가 체계적인 글을 쓴다거나 고심을 하며 글을 쓰는 용도로는 맞지 않습니다. 간단한 초안을 만들 때 쓸 수도 있지만 그 용도로는 굳이 이 앱을 사용할 필요가 없죠. 앱을 켜면 얼마동안 글을 쓸 것인가 타이머와 글꼴을 설정할 수 있습니다. 그 외에는 그냥 제목만 넣으면 바로 글을 쓸 수 있습니다. 아무것도 없는 화면에서 지정한 시간 (기본 5분) 동안 내 머리 속에 떠오르는 생각들, 내 마음 속에 담아두었던 말들을 쭉 써내려가는 겁니다. 아무 방해 없이 말이죠. 잘못 썼다고 수정할 필요도 없습니다. 어떻게 보면 생각나는 대로 적는 의식의 흐름 기법이라고나 할까요. 5초 동안 적는 것을 망설인다면 그동안 적었던 것들이 사라집니다. 처음에 설정한 타이머도 처음으로 돌아갑니다. 물론 단점도 있습니다. 설정한 시간이 흐른 뒤에는 5초의 제약 없이 마음대로 글을 쓰고 편집할 수 있는데요, 이 글들을 관리하는 기능이 부족합니다. 폴더나 카테고리화 할 수 있는 것도 없고 검색 기능도 부족합니다. 또 암호를 이용해서 잠금 기능이 있으면 더 좋을 것 같습니다. 프리라이팅만을 위한 앱은 것 같네요. 어차피 프라이이팅한 글 외에 체계적으로 글을 쓰려면 다른 툴을 써야할 테니까요. 그렇다면 프리라이팅만을 위해서 이 앱을 구매 ($10.99)해야 할까요? 현재 33% 세일 기간입니다. 글을 잘 쓰고 싶은게 글 쓰는 것이 망설여지신다면, 이 앱을 통해 새로운 글쓰기 경험을 해보시는 것도 좋을겁니다. Related Posts","categories":[{"name":"Reviews","slug":"Reviews","permalink":"http://futurecreator.github.io/categories/Reviews/"}],"tags":[{"name":"mac","slug":"mac","permalink":"http://futurecreator.github.io/tags/mac/"},{"name":"writing","slug":"writing","permalink":"http://futurecreator.github.io/tags/writing/"},{"name":"iOS","slug":"iOS","permalink":"http://futurecreator.github.io/tags/iOS/"},{"name":"osx","slug":"osx","permalink":"http://futurecreator.github.io/tags/osx/"}]},{"title":"구글 검색 상위 노출을 위한 200가지 팁","slug":"google-200-ranking-factors-korean-list","date":"2016-06-28T13:44:44.000Z","updated":"2016-06-28T13:52:26.000Z","comments":true,"path":"2016/06/28/google-200-ranking-factors-korean-list/","link":"","permalink":"http://futurecreator.github.io/2016/06/28/google-200-ranking-factors-korean-list/","excerpt":"","text":"아무리 맛있는 맛집이어도 사람들이 몰라서 안오면 안되겠죠. 물론 맛이 좋으면 결국엔 입소문이 퍼지기 마련이지만, 조금이라도 빨리 많은 손님이 오게 하려면 식당을 잘 알려야 합니다. 블로그도 마찬가지죠. 콘텐츠가 좋으면 결국 많은 사람들이 오겠지만 수많은 웹 상에서 많은 방문자가 오게 하려면 검색이 잘 되는 게 필수입니다. 검색 상위 노출 관련해서 www.backlinko.com 의 ‘Google’s 200 Ranking Factors: The Complete List‘ 라는 게시물을 번역해 놓은 좋은 자료가 있어 소개합니다. 구글 상위 노출을 위한 200가지 항목 중 중요한 것들을 손수 번역해놓으셨네요. 감사드립니다. 출처: http://www.marketology.co.kr/?p=422 Domain Age‘도메인이 얼마나 오래되었는가’는 큰 영향을 주지 않는다. Keyword Apperars in Top Level Domain최상위 도메인에 ‘키워드’가 포함되는 것은 영향을 주긴 하나 중요한 요소는 아니다. Domain Registration Length (도메인 유효기간)불온한 사이트라면 단기간에 사이트를 운영하고 방치하는 것을 목적으로 하므로 다년간의 도메인 비용을 미리 지급하진 않을 것이다. 따라서 도메인 비용을 몇 년 치 미리 지급한, 그래서 유효기간이 매우 긴 도메인은 좋은 목적의 잘 관리되는 사이트로 간주한다. Exact Match Domain키워드와 정확히 일치하는 도메인의 경우 연관성이 높은 것으로 보고 높은 점수가 부여된다 Country TLD extension (최상위 도메인에 국가 코드가 포함 예: .kr, .cn, .ca 등)도메인에 국가 코드가 포함될 경우 그 국가에서는 우선순위가 높아지나 국제적으로는 불리할 수 있다. Keyword in Title Tag웹문서의 title 태그에 키워드가 포함되는 것이 매우 큰 작용을 한다. Title Tag Starts with Keywordtitle 태그에 키워드가 포함될 때 앞에 위치하는 것이 더 좋은 작용을 한다. Content Length본문 분량이 많은 것이 상위노출에 유리하다. Latent Semantic Indexing Keywords in Content (LSI)주제가 되는 키워드와 연관성 있는 단어들이 본문에 포함됨으로써 본문의 연관성, 품질 평가가 높아지며 복수의 의미를 지니는 키워드가 보다 정확한 하나의 의미로 규정된다. LSI Keyowrds in Title and Description Tags주제가 되는 키워드와 연관성 있는 단어들이 본문뿐 아니라 타이틀 태그나 디스크립션 태그에 포함되는 것이 좋다. Duplicate Content같은 사이트 내에서도 동일한 내용의 자료가 여러 개 게시되는 건 좋은 영향을 주지 못 한다. Page Loading Speed via Chrome페이지 로딩속도를 크롬 사용자 정보를 통해 확인. 로딩속도가 느리면 불리하다 Keyword Prominence주제어(키워드)가 본문의 처음 100단어 안에 포함되도록 하는 것이 유리하다. Keyword Word Order검색에 사용된 단어의 순서와 본문의 단어순서가 정확히 일치하는 것이 유리하다. 같은 의미의 문구라도 검색사용자가 ‘cat shaving techniques’ 라는 문구를 선호한다면 굳이 본문에 ‘techniques for shaving a cat’이라고 써서 불일치 시킬 필요가 없다. Grammar and Spelling가급적 문법과 맞춤법을 틀리지 않도록 하는 것도 좋은 영향을 준다. Helpful Supplementary Content부수적 컨텐츠, 즉 메인 컨텐츠는 아니지만 방문자가 메인 컨텐츠를 이해하는 데 도움을 주는 기능적 컨텐츠들 예를 들면, 사이트의 네비게이션이나 보험회사의 실시간 견적서, 은행의 환율계산 기능 등이 잘 되어 있는 사이트가 유리하다. Multimedia구글은 멀티미디어(사진, 동영상 등)을 좋아한다. 아마도 이 요소들이 컨텐츠에 대한 빠른 이해를 돕는다고 보기 때문인듯 하다. Priority of Page in Sitemapsitemap.xml 에서 priority가 부여된 페이지가 상위노출에 유리하다. Too Many Outbound Links본문에 필요이상으로 너무 많은 링크를 집어 넣는 것은 좋은 영향을 주지 못 한다. Page Age구글은 새로 만들어진 최신 페이지를 선호하지만 그보다도 오래 되었으면서 자주 업데이트되는 페이지를 더 선호한다. User Friendly Layout사용자 친화적인 레이아웃, 예를 들면 검색사용자가 목표로 했던 메인컨텐츠가 즉각 보여지도록 구성된 페이지가 높은 평가를 받는다 Useful Content페이지 품질과 유용성은 정확히 일치하지 않는다. 품질이 우수하다고 해서 유용성이 큰 것은 아니며 구글은 이들간의 차이를 분명히 인식하고 상충할 경우 균형점을 찾으려 한다. Content Provides Value and Unique Insights:구글은 품질과 유용성이란 관점에서 가치와 독창적 성찰을 제공하는 사이트를 선호한다. Contact Us PageAbout us, Contact info 등 사이트의 정체를 확인할 수 있는 정보가 있을 경우 좋은 평가가 부여된다. 특히 whois 정보와 일치될 경우 더욱 좋은 점수가 부여된다. Presence of Sitemap사이트맵은 검색엔진으로 하여금 사이트를 쉽고 정확하게 인덱싱할 수 있게 해주기 때문에 노출에 좋은 영향을 미친다. Breadcrumb Navigation사용자의 현재 위치를 표시해주는 기능이 있는 것이 유리하다예) 본문 위에 표시되는 ‘Home / SEO / backlink’ 와 같은 형태의 현재 위치를 보여주는 링크주) Breadcrumb 라는 이름은 헨젤과 그레텔이 빵가루를 일정 간격으로 뿌려 둔 데서 유래되었다고 함 Mobile Optimized모바일의 경우 디바이스마다 화면크기가 달라서인지 반응형 웹 디자인(reposnsive web design) 이 구글로부터 권장되는 듯 합니다. 결과적으로 반응형 웹사이트가 모바일 검색순위에 장점을 가지겠네요.) YouTube구글은 멀티미디어를 좋아하는데 그 중에서도 자신들이 소유한 유튜브 동영상을 더 선호한다. Use of Google Analytics and Google Webmaster Tools구글 애널리틱스나 구글 웹마스터 도구를 이용하는 것이 검색결과에 영향을 미친다.주) 단지 이 툴들을 이용한다는 자체만으로 영향을 주는 건 아니고 이 툴들이 사이트에 대한 정확한 정보를 구글에 전달하기 때문에 반영이 정확하고 빠르다는 의미인듯 합니다. 만약 사이트의 품질과 성능이 좋지 못 하다면 이 툴들을 이용하는 것이 오히려 나쁜 영향을 주겠군요. User reviews/Site reputation사용자들의 리뷰가 중요한 역할을 한다. 특히 사이트 내부가 아닌 외부 사이트에서의 리뷰가 특히 중요하다.리뷰/평판의 성격 또한 랭킹에 영향을 준다. 나쁜 평을 통해 백링크를 유도하는 경우 페이지랭크와 상관없이 노출순위가 밀리게 된다. Linking Domain Age백링크되는 도메인이 오래 된 것일수록 유리하다. 백링크란 다른 사이트에서 내 사이트의 링크를 거는 것을 말합니다. # of Linking Root Domains:서브페이지가 아닌 루트 도메인이 백링크 되는 것은 매우 높은 평가를 유도한다. Alt Tag (for Image Links)이미지를 통해 백링크 될 경우 ALT태그가 링크에 대한 텍스트 역할을 한다. ALT태그 안에 주요 키워드가 포함되는 것이 좋다. Links from .edu or .gov Domains교육기관, 정부기관 등을 의미하는 도메인으로부터의 백링크가 좋은 평가에 도움이 된다고 알려져 있다. PR of Linking Page:내 사이트를 참조하는 사이트의 페이지랭크가 높을 수록 유리하다. Links From Competitors동일 키워드에 대한 검색결과 순위를 놓고 경쟁하는 사이트로부터의 백링크는 다른 사이트의 백링크보다 더 크게 작용한다. Social Shares of Referring Page내 사이트를 참조하는 사이트의 소셜공유가 많을 수록 유리하다. Links to Homepage Domain that Page Sits On백링크가 내 사이트를 참조하는 사이트의 홈페이지(메인페이지)에 걸려 있는 것이 유리하다. Diversity of Link Types백링크가 다양한 여러 경로로부터 오는 것이 자연스럽게 인식된다. 하나의 프로필 페이지나 댓글에 너무 많은 백링크가 달리는 것은 스팸으로 간주될 수 있다. Backlink Anchor Text백링크에 사용된 앵커텍스트는 연결되는 페이지의 성격을 규정하는데 큰 작용을 한다. Link Location In Content내 사이트를 참조하는 페이지에서 백링크의 위치가 아래 보다는 위에 있을 땐 약간 유리하다. Text Around Link Sentiment구글은 백링크가 긍정적인 혹은 부정적인 맥락에서 사용되었는가를 파악하고 긍적적인 목적의 인용에 대해 좋은 평가를 주는 듯 하다. Link from Authority Sites권위 있는 사이트로부터의 백링크가 그렇지 못 한 사이트의 것보다 유리하다. Linked to as Wikipedia Source위키피디아의 링크가 nofollow 이지만 그렇더라도 위키피디아에 링크가 걸리는 것이 긍정적으로 작용한다고 보고 있다.주) nofollow라는 것은 로봇이 링크를 따라 이동하며 크롤링 할때 그 링크는 배제한다는 의미입니다 User Generated Content Links사용자가 만든 컨텐츠로부터의 백링크인지 사이트 오너가 만든 컨텐츠로부터의 백링크인지에 따라 평가 달라짐. 후자에 더 큰 가치가 부여됨. Word Count of Linking Content장문의 글에 걸린 백링크가 짧은 단문의 백링크보다 큰 가치를 부여받는다. Oranic Click Through Rate for a KeywordCTR이 높은 페이지가 상위노출에 유리하다. Bounce Rate모두가 동의하는 건 아니지만 대부분의 SEO전문가들이 이탈률이 검색결과 순위에 영향을 주는 것으로 믿고 있다. 아마도 구글은 페이지를 방문한 사용자들이 얼마나 빨리 페이지 혹은 사이트를 이탈하는가를 통해 품질을 체크하고 있을 것이다. Direct Traffic구글은 크롬 사용자들의 사용기록을 통해 사이트의 직접 방문수를 파악하고 그 숫자가 많을 경우 품질이 우수한 것으로 간주한다. Repeat Traffic높은 재방문율 또한 긍정적인 평가요인이 된다. Chrome Bookmarks크롬의 북마크 혹은 IE에 설치된 구글툴바를 통해 북마크되는 사이트들은 좋은 평가를 받는다. Number of Comments댓글이 많이 달리는 페이지가 높은 평가를 받는다. Dwell Time검색을 통해 방문한 페이지의 체류시간이 긴 것이 좋다.주) 따라서 내용이 길고 읽을만 하며 키워드와 연관성이 있어야 합니다. Query Deserves Freshness새로 생성된 페이지에 가산점을 준다. 그러나 정해진 범주 내의 키워드에 한한다. 최신성이 의미가 없는 페이지는 새로 생성되었다고 해서 우대되거나 오래 되었다고 해서 등한시하지 않는다. User Browsing History구글에 로그인한 상태에서 자주 방문한 페이지는 그 사용자에 한해 검색결과 순위가 올라간다. User Search History최근에 검색한 키워드들과 관련 있는 페이지의 검색결과 순위가 올라간다. Geo Targeting검색사용자의 해당 지역 사이트나 국가코드 도메인이 우선 노출된다. Number of Tweets, Number of Facebook Likes, Facebook Shares트윗이나 좋아요, 공유의 수가 많을 수록 유리하다. Authority of Twitter Users Accounts, Authority of Facebook User Accounts소셜공유를 한 트위터나 페이스북의 계정이 권위 있는 사용자의 것일 수록 유리하다. Related Posts 구글(Goolge) 사이트 등록(Search Console)과 검색엔진 최적화(SEO) 네이버 사이트 등록(웹마스터 도구)과 검색엔진 최적화(SEO) Hexo 블로그에 구글 애드센스(Adsense) 추가하기 오픈 그래프 (Open Graph) 태그와 페이스북 도메인 인사이트 (Domain Insight) 구글(Google) 검색 원리와 검색이 잘 되게 하는 방법 검색 엔진 최적화(SEO)에 유용한 Hexo 플러그인 구글 검색 상위 노출을 위한 200가지 팁","categories":[{"name":"Web","slug":"Web","permalink":"http://futurecreator.github.io/categories/Web/"},{"name":"Hexo","slug":"Web/Hexo","permalink":"http://futurecreator.github.io/categories/Web/Hexo/"}],"tags":[{"name":"google","slug":"google","permalink":"http://futurecreator.github.io/tags/google/"},{"name":"search","slug":"search","permalink":"http://futurecreator.github.io/tags/search/"}]},{"title":"스위프트(Swift) 시작하기","slug":"swift-get-started","date":"2016-06-27T14:50:15.000Z","updated":"2016-06-27T14:52:04.000Z","comments":true,"path":"2016/06/27/swift-get-started/","link":"","permalink":"http://futurecreator.github.io/2016/06/27/swift-get-started/","excerpt":"","text":"About SwiftSwift is a new programming language for iOS, OS X, watchOS, and tvOS apps that builds on the best of C and Objective-C, without the constraints of C compatibility Apple Inc.The Swift Programming Language iOS 개발을 시작하면서 스위프트 (Swift) 공부를 시작했습니다. 스위프트는 애플이 새롭게 소개한 iOS, OS X 개발을 위한 언어입니다. 새로운 언어로의 전환은 굉장히 큰 일이죠. 구글이 안드로이드를 만드는 언어로 자바와 완전히 호환되는 새로운 언어를 공개한다고 상상해보니 이게 얼마나 중요한 일인지 더 와닿는 것 같습니다. 처음 시작하는 저에게는 Objective-C 나 스위프트나 새롭기는 매한가지지만, 이왕 배우려면 스위프트를 배우는 게 낫겠죠? 스위프트를 간단히 공부해보면서 느낀 점은 두 가지입니다. 재밌다, 그리고 생소하다. 세미콜론도 없고 간단한 syntax 는 불필요한 작업 없이 코드를 빠르게 작성하게 해주었습니다. 스위프트 (Swift; 재빠른, 신속한)의 이름만 봐도 알 수 있죠. 하지만 생략할 수 있는 부분이 많다보니, 같은 코드라도 여러 가지로 표현이 가능했습니다. 생산성이 높아지겠지만 읽기가 어려웠습니다. 물론 자바도 개발자마다 코딩 스타일이 달라서 프로젝트마다 코딩 스타일 가이드가 있긴 합니다만 이 정도로 다르진 않았습니다. 게다가 너무 줄여놓으면 다른 사람이 만든 코드를 읽기가 어려울 것 같았습니다. 유지보수를 위해 소스의 가독성이 높은 코드가 인정을 받았다면 이제는 생산성이 더 중요한 것인가 싶기도 합니다. 애플이 만든 Swift 공식 가이드를 iBooks 에서 다운받을 수 있었습니다. 혹은 애플 개발자 홈페이지 에서 확인가능합니다. 그래서 공부할 자료가 따로 필요 없었죠. 한 문장 한 문장 번역을 할 순 없을 것 같고 코드만 가져오겠습니다. 가이드 내에 있는 모든 코드를 작성해보고 공부한 내용을 정리하는 식으로 진행하려고 합니다. 좋은 책은 예제에 모든 내용을 함축하고 있다고 생각하거든요. Swift Tour첫 장은 Swift Tour 입니다. 자세한 설명보다는 전체적으로 스위프트를 훑어보는 장이군요. 먼저 ‘Hello, world!’ 를 출력해봅시다. 세미콜론을 생략할 수 있습니다. 세미콜론 안쓰는게 처음에는 낯설었는데 금방 익숙해지네요. 1print(\"Hello, World!\") Simple Values변수는 값을 할당한 후 변경이 가능하고, 상수는 값을 한번만 할당 가능합니다. 변수와 상수 모두 선언 시 반드시 값을 할당해야 합니다. 123456// 변수var myVariable = 42myVariable = 50// 상수let myConstant = 42 타입 선언입니다. 타입을 지정하지 않으면 초기값으로 타입을 유추합니다. 타입이 맞지 않으면 에러가 납니다. 타입은 한번 정해지면 변경할 수 없습니다. 1234let implicitInteger = 70let implicitDouble = 70.0let explicitDouble: Double = 70let explicitFloat: Float = 4 // 타입 에러 타입의 암묵적 변환은 할 수 없고 명시적으로만 가능합니다. 1234let label = \"The width is\"let width = 94let widthLabel = label + String(width) // 타입 변환widthLabel = label + width // 타입 에러 문자열 안에 값을 표현하려면 백슬래시() 안에 표현할 값을 넣습니다. 1234let apples = 3let oranges = 5let appleSummary = \"I have \\(apples) apples.\"let fruitSummary = \"I have \\(apples + oranges) pieces of fruit.\" 배열 (Array)은 인덱스 (index)를 가지고 순차적으로 값을 저장하는 자료구조입니다. 12var shoppingList = [\"catfish\", \"water\", \"tulips\", \"blue paint\"]shoppingList[1] = \"bottle of water\" Dictionary 는 key 와 value 쌍으로 자료를 저장하는 자료구조입니다. 12345var occupations = [ \"Malcolm\": \"Captain\", \"Kaylee\": \"Mechanic\"]occupations[\"Jayne\"] = \"Public Relations\" 빈 배열과 Dictionary 를 만들려면 타입을 지정해서 초기화 함수를 사용합니다. 123456let emptyArray = [String]()let emptyDictionary = [String: Float]()// 타입을 지정하기 전에는 다음과 같이 빈 값을 할당shoppingList = []occupations = [:] Control Flow조건문과 반복문을 알아봅시다. 조건문 if switch 반복문 for-in for while repeat-while 12345678910let individualScroes = [75, 42, 103, 87, 12]var teamScore = 0for score in individualScroes &#123; if score &gt; 50 &#123; teamScore += 3 &#125; else &#123; teamScore += 1 &#125;&#125;print(teamScore) ifif 조건부에 오는 값은 반드시 Boolean 표현식이어야 합니다. 123if teamScore &#123; // 타입 에러 // ...&#125; 타입 뒤에 물음표 (?) 를 붙이면 Optional 값이 됩니다. Optinal 값은 값이 없을 수도 있음을 의미합니다. 빈 값이라던가 의미 없는 값이라던가 하는 것도 결국 값이 있는 것이고, 값이 없다는 것은 아직 값이 할당되지 않은 상태를 명시적으로 표시하는 방법입니다. nil 은 값이 없음을 표현합니다 (기존의 null 을 생각하면 됩니다). 12var optionalString: String? = \"Hello\"print(optionalString == nil) if 와 let 을 같이 쓰는 경우, optionalName 이 nil 이 아니면 true, nil 이면 false 값을 갖습니다. 만약 nil 이 아니면 해당 블록 내에서 name 이라는 상수로 사용 가능합니다.123456789var optionalName: String? = \"John Appleseed\"var greeting = \"Hello!\"if let name = optionalName &#123; greeting = \"Hello, \\(name)\"&#125; else &#123; greeting = \"Hello, Unknown\"&#125;print(greeting) ?? 연산자는 nickName 이 nil 인 경우에 default 값을 줍니다. 1234let nickName: String? = nillet fullName: String = \"John Appleseed\"let informalGreeting = \"Hi \\(nickName ?? fullName)\"print(informalGreeting) Switchswitch 문을 살펴봅시다. 다양한 값과 비교 연산자를 사용 가능하고, break 문이 필요없습니다. 1234567891011121314let vagetable = \"red pepper\"switch vagetable &#123;case \"celery\": print(\"Add some raisins and make ants on a log.\")case \"cucumber\", \"watercress\": // 여러 케이스를 지정하는 경우 print(\"that would make a good tea sandwich.\")case let x where x.hasSuffix(\"pepper\"): print(\"Is it a spicy \\(x)?\")default: // default 존재하지 않으면 에러가 난다 print(\"Everything tastes good in soup.\")&#125; for-in반복문 중 하나인 for-in 문 입니다. 배열과 Dictionary 를 순회할 수 있습니다. 12345678910111213141516let interestingNumbers = [ \"Prime\": [2, 3, 5, 7, 11, 13], \"Fibonacci\": [1, 1, 2, 3, 5, 8], \"Square\": [1, 4, 9, 16, 25]]var largest = 0for (kind, numbers) in interestingNumbers &#123; for number in numbers &#123; if number &gt; largest &#123; largest = number &#125; &#125;&#125;print(largest) whilewhile 문은 조건에 만족하는 동안 작업을 반복 수행합니다. 12345var n = 2while n &lt; 100 &#123; n = n * 2&#125;print(n) reapeat 문을 사용하면 조건을 체크하기 전에 먼저 작업을 수행하기 때문에 최소한 한 번은 작업을 수행합니다. do-while 문을 생각하시면 됩니다. 1234567891011121314var m = 2repeat &#123; m = m * 2&#125; while m &lt; 100print(m)// ... 는 같은 값까지 확인// ..&lt; 는 값 미만까지 확인var total = 0for i in 0 ..&lt; 4 &#123; // 0, 1, 2, 3 total += i&#125;print(total) Functions and ClosuresFunctionsfunc 를 사용해서 함수를 선언합니다. arguments 는 타입을 지정해주고, -&gt; 뒤에는 리턴 타입을 명시합니다. 함수 사용 시에는 파라미터 이름에 맞춰 넣습니다. 여기서 첫번째 파라미터는 파라미터 이름을 생략 가능합니다. 1234func greet(name: String, day: String) -&gt; String &#123; return \"Hello \\(name), today is \\(day).\"&#125;greet(\"Bob\", day: \"Tuesday\") 함수는 값을 여러 개 반환할 수 있습니다. 더 정확히 얘기하면 Tuple 로 여러 값을 묶어서 한번에 반환할 수 있습니다. Tuple 은 값을 묶어주는 것으로 구조체나 클래스 같은 것보다 간편하게 값을 묶는 용도로 사용합니다. 12345678910111213141516171819202122func calculateStatistics(scores: [Int]) -&gt; (min:Int, max:Int, sum:Int) &#123; var min = scores[0] var max = scores[0] var sum = 0 for score in scores &#123; if score &gt; max &#123; max = score &#125; else if score &lt; min &#123; min = score &#125; sum += score &#125; return (min, max, sum)&#125;let statistics = calculateStatistics([5, 3, 100, 3, 9])print(statistics.sum) // . 으로 접근 가능print(statistics.2) // 0, 1, 2 순서로 sum 을 가리킴 함수는 여러개의 가변인자를 받을 수 있고, 가변 인자는 배열처럼 접근 가능합니다. 12345678910111213func sumOf(numbers: Int...) -&gt; Int &#123; var sum = 0 print(numbers.count) // 배열처럼 사용 가능 for number in numbers &#123; sum += number &#125; return sum&#125;sumOf() // 인자가 없어도 에러가 나지 않는다sumOf(42, 597, 12) 함수 내부에 함수를 선언할 수 있습니다 (중첩함수; Nested function). 중첩함수는 바깥쪽 함수에서 변수처럼 사용이 가능합니다. 또한 자세히 보시면 중첩함수인 add() 에서 바깥쪽 함수의 변수인 y 에 접근하고 있는 걸 볼 수 있습니다. 이것이 클로저 (Closure)의 개념 중 하나입니다. 123456789101112func returnFifteen() -&gt; Int &#123; var y = 10 func add() &#123; y += 5 &#125; add() return y&#125;returnFifteen() 함수는 1급 타입입니다. javaScript 의 함수를 생각하시면 됩니다. 1급 타입이라는 것은, 변수에 담을 수 있다. 인자로 받을 수 있다. 반환이 가능하다.을 의미합니다. 다음 코드는 함수를 리턴하고 함수를 변수에 담는 예제입니다. 1234567891011121314// -&gt; ((Int) -&gt; Int)// Int 를 파라미터로 받고 Int 를 리턴하는 함수 타입을 리턴func makeIncrementer() -&gt; ((Int) -&gt; Int) &#123; func addOne(number: Int) -&gt; Int &#123; return 1 + number &#125; // addOne 이라는 함수 자체를 리턴 return addOne&#125;// 리턴되는 함수를 변수에 받아서 실행 가능var increment = makeIncrementer()increment(7) 다음 코드는 함수를 파라미터로 받는 예제입니다. 123456789101112131415161718func hasAnyMatches(list: [Int], condition: (Int) -&gt; Bool) -&gt; Bool &#123; for item in list &#123; if condition(item) &#123; return true &#125; &#125; return false&#125;func lessThanTen(number: Int) -&gt; Bool &#123; return number &lt; 10&#125;var numbers = [20, 19, 7, 12]hasAnyMatches(numbers, condition: lessThanTen) Closure클로저는 어떠한 함수와 그 함수의 환경 (컨텍스트)를 묶어놓은 것입니다. 그 환경은 클로저를 어떻게 만드느냐에 따라 결정됩니다. 중첨첩 함수에서도 클로저를 볼 수 있었습니다. 클로저에 대한 자세한 내용은 따로 포스트를 만들어야 할 것 같네요. 어쨌든 Swift 의 클로저는 무명함수 (Anonymous Functions) 로 선언 가능합니다. in 키워드 앞에는 클로저의 파라미터와 리턴 타입을 명시합니다. 아래 코드의 클로저는 배열의 각 숫자에 3을 곱하는 작업을 수행하게 됩니다. 12345numbers.map(&#123; (number: Int) -&gt; Int in // 파라미터와 리턴 타입 let result = 3 * number return result&#125;) 여기서 함수의 파라미터와 리턴 타입을 아는 경우 생략할 수 있습니다. 여기서는 map 의 파라미터로 들어오는 함수의 파라미터와 리턴 타입이 정해져 있는 상태입니다. 이럴 때는 생략이 가능합니다. 리턴 구문도 생략 가능합니다. 12345let mappedNumbers = numbers.map(&#123; number in // 클롤저의 파라미터 타입과 리턴 타입을 생략 3 * number // 리턴 구문 생략&#125;)print(mappedNumbers) 여기서 더 줄일 수 있습니다. 매개변수를 받는 괄호 안에 중괄호 ({}) 를 이용해서 클로저를 넣었는데요, 이 때 괄호를 생략하고 중괄호 형태로 수정이 가능합니다. 게다가 매개변수의 이름까지 생략하고 번호를 이용해서 참조할 수도 있습니다. $0 은 첫 번째 파라미터를, ‘$1’ 은 두 번째 파라미터를 말합니다. 따라서 다음과 같이 표현이 가능합니다. 123numbers.map &#123; 3 * $0&#125; 너무 생소해져서 스위프트가 싫어질 것 같네요.. 하지만 익숙해지면 편할 것 같습니다. 아래는 다른 예입니다. 1234let sortedNumbers = numbers.sort &#123; $0 &gt; $1&#125;print(sortedNumbers) Object and Classes클래스는 변수와 메소드 (함수)로 이루어져 있습니다. 다음과 같이 선언할 수 있습니다. 1234567class Shape &#123; var numberOfSides = 0 func simpleDescription() -&gt; String &#123; return \"A shape with \\(numberOfSides) sides.\" &#125;&#125; 인스턴스를 생성하고 인스턴스에 접근하는 방법입니다. 123var shape = Shape()shape.numberOfSides = 7var shapeDescription = shape.simpleDescription(); 클래스 내 변수는 선언할 때 초기값을 할당하거나 init 생성자를 이용해서 초기화해야 합니다. self 키워드는 해당 클래스의 변수를 의미합니다. 1234567891011121314class NamedShape &#123; var numberOfSide: Int = 0 var name: String // 초기화 init(name: String) &#123; self.name = name &#125; func simpleDescription() -&gt; String &#123; return \"A shape with \\(numberOfSide) sides.\" &#125;&#125; 상속입니다. 상속은 클래스명 뒤에 : 를 붙여서 상속할 클래스를 표시합니다. 12345678910111213141516171819202122class Square: NamedShape &#123; var sideLength: Double init(sideLength: Double, name: String) &#123; self.sideLength = sideLength super.init(name: name) numberOfSide = 4 // 부모 클래스의 변수 &#125; func area() -&gt; Double &#123; return sideLength * sideLength &#125; override func simpleDescription() -&gt; String &#123; return \"A square with sides of length \\(sideLength).\" &#125;&#125;let test = Square(sideLength: 5.2, name: \"my test square\")test.area()test.simpleDescription() 프로퍼티는 getter 와 setter 를 가질 수 있습니다. 123456789101112131415161718192021222324252627282930class EquilateralTriangle: NamedShape &#123; var sideLength: Double = 0.0 init(sideLength: Double, name: String) &#123; self.sideLength = sideLength // 하위 클래스의 속성 값 지정 super.init(name: name) // 상위 클래스 init 호출 numberOfSide = 3 // setter 없이 그냥 접근 가능함 &#125; var perimeter: Double &#123; get &#123; return 3.0 * sideLength &#125; set &#123; // newValue 는 새로운 값을 의미 sideLength = newValue / 3.0 &#125; &#125; override func simpleDescription() -&gt; String &#123; return \"An equilateral triangle with sides of length \\(sideLength).\" &#125;&#125;var triangle = EquilateralTriangle(sideLength: 3.1, name: \"a triangle\")print(triangle.perimeter) // 9.3triangle.perimeter = 9.9print(triangle.sideLength) // 3.3 willSet 과 didSet 을 이용해서 setter 를 수행하기 전, 후에 실행되는 코드를 작성할 수 있습니다. 12345678910111213141516171819202122232425class TriangleAndSquare &#123; var square: Square &#123; willSet &#123; triangle.sideLength = newValue.sideLength &#125; &#125; var triangle: EquilateralTriangle &#123; willSet &#123; square.sideLength = newValue.sideLength &#125; &#125; init(size: Double, name: String) &#123; square = Square(sideLength: size, name: name) triangle = EquilateralTriangle(sideLength: size, name: name) &#125;&#125;var triangleAndSquare = TriangleAndSquare(size: 10, name: \"another test shape\")print(triangleAndSquare.square.sideLength) // 10print(triangleAndSquare.triangle.sideLength) // 10triangleAndSquare.square = Square(sideLength: 50, name: \"larger square\")print(triangleAndSquare.triangle.sideLength) // 50 클래스를 Optional 로 선언하면 nil 값이 올 수 있습니다. 사용할 때는 물음표 (?)를 붙여서 사용해야 합니다. 12let optionalSqure: Square? = Square(sideLength: 2.5, name: \"optional square\")let sideLength = optionalSqure?.sideLength Enumerations and StructuresEnumerations열거형은 값을 나열해서 표현하는 것으로 값이 중요한 것이 아니라, 순서 상 값을 구분하는 용도로 만든 자료형입니다. 열거형에는 타입을 지정할 수 있고 메서드를 포함할 수 있습니다. 열거형의 값은 자동으로 할당되는데 아래 코드에서는 첫번째 값을 1로 주었기 때문에 차례로 2, 3, 4 순으로 할당됩니다. 12345678910111213141516171819202122232425262728enum Rank: Int &#123; case Ace = 1 case Two, Three, Four, Five, Six, Seven, Eight, Nine, Ten case Jack, Queen, King func simpleDescription() -&gt; String &#123; switch self &#123; case .Ace: return \"ace\" case .Jack: return \"jack\" case .Queen: return \"queen\" case .King: return \"king\" default: return String(self.rawValue) &#125; &#125;&#125;let ace = Rank.Acelet aceRawValue = ace.rawValue // 실제값print(ace) // Aceprint(aceRawValue) // 1print(Rank.Queen) // Queenprint(Rank.Queen.rawValue) // 12 init?(rawValue:) initializer 를 이용해서 rowValue 로 열거형 인스턴스를 생성할 수 있습니다. 123if let convertedRank = Rank(rawValue: 3) &#123; let threeDescription = convertedRank.simpleDescription()&#125; 1234567891011121314151617181920enum Suit &#123; case Spades, Hearts, Diamonds, Clubs func simpleDescription() -&gt; String &#123; switch self &#123; case .Spades: return \"spades\" case .Hearts: return \"hearts\" case .Diamonds: return \"diamonds\" case .Clubs: return \"clubs\" &#125; &#125;&#125;let hearts = Suit.Heartslet heartDescription = hearts.simpleDescription() Struct구조체는 struct 키워드를 이용해 선언합니다. 구조체는 클래스와 거의 비슷하지만 보통 인스턴스가 참조 복사 형태로 전달된다는 점과 달리, 값 복사 형태로 전달됩니다. 1234567891011121314struct Card &#123; var rank: Rank var suit: Suit func simpleDescription() -&gt; String &#123; return \"The \\(rank.simpleDescription()) of \\(suit.simpleDescription())\" &#125;&#125;let threeOfSpades = Card(rank: .Three, suit: .Spades)let threeOfSpadesDescription = threeOfSpades.simpleDescription()print(threeOfSpades) // Card(rank: HelloSwift.Rank.Three, suit: HelloSwift.Suit.Spades)print(threeOfSpadesDescription) // The 3 of spades Associatd Value 는 Enumerations 의 case 에 특정한 값을 할당해서 저장한 후에 나중에 활용할 수 있는 방식입니다. 아래 코드를 보시면 ServerResponse 는 Result(String, String) 또는 Failure(String) 둘 중 하나의 값만을 가질 수 있는 상태입니다. 값을 할당 시에 저장한 두 개의 String 값은 switch 문에서 아래 코드와 같이 사용 가능합니다. 12345678910111213141516enum ServerResponse &#123; case Result(String, String) case Failure(String)&#125;let success = ServerResponse.Result(\"6:00 am\", \"8:09 pm\")let failure = ServerResponse.Failure(\"Out of cheese.\")switch success &#123;case let .Result(sunrise, sunset): // case .Result(let sunrise, let sunset) 과 같은 의미 // Sunrise is at 6:00 am and sunset is at 8:09 pm. print(\"Sunrise is at \\(sunrise) and sunset is at \\(sunset).\")case let .Failure(message): print(\"Failure... \\(message)\")&#125; Protocols and ExtensionsProtocols프로토콜은 자바의 인터페이스와 비슷한 개념입니다. 반드시 구현해야 하는 것을 명시할 수 있습니다. 프로토콜은 일종의 타입으로써 다형성을 구현할 수 있습니다. 1234protocol ExampleProtocol &#123; var simpleDescription: String &#123; get &#125; mutating func adjust()&#125; 클래스 뿐만 아니라, Enumerations 와 구조체에도 프로토콜을 적용할 수 있습니다. 123456789101112131415161718192021222324252627282930313233343536// Classclass SimpleClass: ExampleProtocol &#123; var simpleDescription: String = \"A very simple class.\" var anotherProperty: Int = 69105 func adjust() &#123; simpleDescription += \" Now 100% adjusted.\" &#125;&#125;var a = SimpleClass()print(a.simpleDescription) // A very simple classa.adjust()let aDescription = a.simpleDescriptionprint(aDescription) // A very simple class. Now 100% adjusted.// Structurestruct SimpleStructure: ExampleProtocol &#123; var simpleDescription: String = \"A simple structure\" mutating func adjust() &#123; simpleDescription += \" (adjusted)\" &#125;&#125;var b = SimpleStructure()print(b.simpleDescription)b.adjust()let bDescription = b.simpleDescriptionprint(bDescription) ExtensionsExtension 은 기존의 객체 타입에 코드를 추가할 수 있는 기능입니다. 라이브러리나 프레임워크의 소스에도 추가할 수 있습니다. 1234567891011extension Int: ExampleProtocol &#123; var simpleDescription: String &#123; return \"The number \\(self)\" &#125; mutating func adjust() &#123; self += 42 &#125;&#125;print(7.simpleDescription) Generics제네릭 (Generics)는 특정 타입임을 명시하는 방법입니다. 12345678func repeatItem&lt;Item&gt;(item:Item, numberOfTimes: Int) -&gt; [Item] &#123; var result = [Item]() for _ in 0..&lt;numberOfTimes &#123; result.append(item) &#125; return result&#125;repeatItem(\"knock\", numberOfTimes:4) 스위프트의 Optional Value 를 제네릭을 이용해 표현해보면 다음과 같습니다. 1234567enum OptionalValue&lt;Wrapped&gt; &#123; case None case Some(Wrapped)&#125;var possibleInteger: OptionalValue&lt;Int&gt; = .NonepossibleInteger = .Some(100) where 키워드를 이용해서 특정 타입에 대한 조건을 줄 수도 있습니다. 123456789101112func anyCommonElements &lt;T:SequenceType, U:SequenceType where T.Generator.Element:Equatable, T.Generator.Element == U.Generator.Element&gt; (lhs:T, _ rhs: U) -&gt; Bool &#123; for lhsItem in lhs &#123; for rhsItem in rhs &#123; if lhsItem == rhsItem &#123; return true &#125; &#125; &#125; return false&#125;anyCommonElements([1,2,3], [3]) 전체적으로 어떤 모양새인지 훑어보는 장이었습니다. 만만한 언어는 아닌 것 같네요. 하지만 여기서 이해가 가질 않는 부분이 있더라도 뒤에서 자세하게 살펴볼 것이니 크게 상관 없을 것 같습니다. 다음 포스팅에서는 앞에서부터 차근차근 다뤄보겠습니다.","categories":[{"name":"App","slug":"App","permalink":"http://futurecreator.github.io/categories/App/"},{"name":"iOS","slug":"App/iOS","permalink":"http://futurecreator.github.io/categories/App/iOS/"}],"tags":[{"name":"swift","slug":"swift","permalink":"http://futurecreator.github.io/tags/swift/"},{"name":"start","slug":"start","permalink":"http://futurecreator.github.io/tags/start/"}]},{"title":"Hexo .DS_Store TypeError 해결 방법","slug":"hexo-ds-store-error","date":"2016-06-24T05:24:22.000Z","updated":"2016-06-24T06:11:00.000Z","comments":true,"path":"2016/06/24/hexo-ds-store-error/","link":"","permalink":"http://futurecreator.github.io/2016/06/24/hexo-ds-store-error/","excerpt":"","text":"오늘도 Hexo 블로그를 열심히 하던 중에 알 수 없는 에러를 만났습니다. 이것 때문에 generate 는 커녕 로컬 서버도 안되더군요. 별로 바꾼 것도 없는데 이렇게 되니 당황스러웠습니다. 12ERROR Process failed: layout/.DS_StoreTypeError: Cannot read property &apos;compile&apos; of undefined .DS_Store 파일일단 .DS_Store 파일이 뭔지 찾아봤습니다. .DS_Store 파일은 해당 폴더의 설정을 가지고 있는 파일이라고 합니다. 자동으로 생성되고 점(.) 을 붙여서 숨김파일 처리 되어있어서 평소엔 보이지 않습니다. 해결 방법Windows일단 Windows 에서 작업하시는 분들은 .DS_Store 파일이 나올 일은 없으나 Mac 에서 제작한 테마를 받을 경우에 테마 안에 포함되어 있는 경우가 있다고 합니다. 그럴 경우에 그냥 삭제하시면 다시는 나타나지 않을 겁니다. Mac첫번째 시도Stack Overflow 에서 검색해본 결과 Hexo 3.2.0 에서만 발생하는 문제이니 3.1.1 로 다운그레이드하면 된다는 의견이 많았습니다. 하지만 백업을 해놓고 다운그레이드 했는데도 동일한 증상이 나타나더군요. 댓글들을 읽어보니 명백한 버그가 맞는 것 같네요. 두번째 시도이번에는 그냥 아예 폴더를 없애고 다시 만들었습니다. 새 폴더에다가 hexo init 부터 시작해서 테마도 받고 플러그인도 따로 설치했습니다. 그리고 문제의 그 파일이 같이 복사되지 않도록 조심스럽게 복사를 한 결과! 동일한 증상이 계속 나타났습니다. 세번째 시도어렵사리 만들어놓은 블로그가 안되니 참 답답하더군요. 그래서 마음이 좀 급했나 봅니다. 문제의 파일인 .DS_Store 에 대해 다시 검색해보니, .DS_Store 는 삭제해도 별 문제가 없고 다시 생성되는 파일이라는 점입니다. 그래서 그냥 문제의 파일을 삭제하고 generate 했더니 잘 됩니다.. 그런데 몇번 더 해보니 가끔씩 문제가 발생하더군요. 어떤 기준인지는 잘 모르겠으나 그 때마다 삭제를 해야한다니 이건 분명히 버그인 것 같습니다. compile 하는 부분에서 .DS_Store 파일을 제외해야 하는데 그런 로직이 없는 것 같네요. 결론은 문제의 파일을 삭제하면 됩니다. Related Posts 워드프레스보다 쉬운 Hexo 블로그 시작하기 Hexo 추천 테마, Hueman 적용하기 Hexo 기본 사용법 Hexo 태그 플러그인 (Tag plugins) 살펴보기 Hexo 네임카드 추가하기 (Github Card) Hexo 에 Github 저장소 타임라인 (Repository timeline) 정보 추가하기 Hexo 블로그에 구글 애드센스(Adsense) 추가하기","categories":[{"name":"Web","slug":"Web","permalink":"http://futurecreator.github.io/categories/Web/"},{"name":"Hexo","slug":"Web/Hexo","permalink":"http://futurecreator.github.io/categories/Web/Hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://futurecreator.github.io/tags/hexo/"},{"name":".DS_Store","slug":"DS-Store","permalink":"http://futurecreator.github.io/tags/DS-Store/"},{"name":"error","slug":"error","permalink":"http://futurecreator.github.io/tags/error/"}]},{"title":"검색 엔진 최적화(SEO)에 유용한 Hexo 플러그인","slug":"search-engine-optimization-hexo-plugins","date":"2016-06-23T07:02:47.000Z","updated":"2016-08-17T13:58:56.000Z","comments":true,"path":"2016/06/23/search-engine-optimization-hexo-plugins/","link":"","permalink":"http://futurecreator.github.io/2016/06/23/search-engine-optimization-hexo-plugins/","excerpt":"","text":"이전 포스트에서 검색과 웹 사이트 최적화에 대해 이야기를 했습니다. 구글 검색 엔진이 어떻게 동작하는지, 내 블로그가 검색이 잘 되게 하기 위해서 구글/네이버 웹 마스터 도구를 이용해서 페이지를 최적화했습니다. 구글(Google) 검색 원리와 검색이 잘 되게 하는 방법 구글(Goolge) 사이트 등록(Search Console)과 검색엔진 최적화(SEO) 네이버 사이트 등록(웹마스터 도구)과 검색엔진 최적화(SEO) 오픈 그래프 (Open Graph) 태그와 페이스북 도메인 인사이트 (Domain Insight) 이렇게 검색 엔진 최적화 (SEO; Search Engine Optimization) 를 도와주는 Hexo 플러그인들을 정리해봤습니다. 이번 포스팅에서 살펴볼 플러그인들은 다음과 같습니다. hexo-autonofollow hexo-auto-canonical hexo-generator-feed hexo-generator-seo-friendly-sitemap hexo-autonofollow해당 포스트에서 참고하고 있는 외부 링크에 nofollow 속성을 자동으로 추가해주는 플러그인입니다. 먼저 nofollow 속성이 무엇이고 왜 추가해야하는지 알아보겠습니다. nofollow 속성검색엔진에서 사용자에게 검색한 결과 페이지를 보여주기 위해 평소에 많은 웹 사이트를 수집해놓습니다. 그러한 작업을 크롤링 이라고 하고 크롤링하는 로봇을 크롤러 또는 구글의 경우 구글봇 (Googlebot) 이라고 합니다. 이 크롤러에게 이 페이지는 수집하지 말라고 알려줄 수 있습니다. 크롤러가 페이지를 수집한다는 것은 검색 결과에 노출될 수 있다는 얘기입니다. 따라서 개인정보나 유료링크 같은 것들은 수집하면 안되겠죠. 이 때 사용하는 것이 robot.txt 파일입니다. 크롤러는 홈페이지에 있는 robot.txt 파일을 참고해서 크롤링에서 예외처리할 페이지를 확인합니다. 혹은 간단하게 해당 페이지의 &lt;head&gt; 태그 안에 메타 태그로 표시할 수 있습니다. 1&lt;meta name=\"robots\" content=\"nofollow\" /&gt; 그런데 해당 페이지 내에 있는 개별 링크에 대해서는 어떻게 처리할까요? 이런 작업은 robot.txt 로 처리하는 것이 복잡해서 rel 속성에 nofollow 속성값이 생겼습니다. 이 속성을 통해서 해당 링크는 크롤링하지 않도록 할 수 있습니다. 보통 신뢰할 수 없는 콘텐츠나 유료 링크의 경우 다른 사용자의 검색에 노출되지 않아야 하므로 nofollow 속성을 사용하는 것이 좋습니다. 1&lt;a href=\"signin.php\" rel=\"nofollow\"&gt;로그인&lt;/a&gt; 기능 모든 외부 링크에 rel=&quot;external nofollow&quot; 속성을 자동으로 추가합니다. 외부링크에만 동작하기 때문에 본인 사이트의 도메인 링크는 제외됩니다. 외부 링크에 target=&quot;_blank&quot; 속성을 넣어서 클릭할 경우 새로운 탭 또는 윈도우에서 열리게 합니다. 설치1$ npm install hexo-autonofollow --save 옵션_config.yml12345nofollow: enable: true exclude: - exclude1.com - exclude2.com 옵션 설명 enable 플러그인 활성화 exclude 제외할 호스트 결과일단 두 개의 링크를 작성해봅시다. 내 홈페이지네이버 브라우저로 접속해서 개발자 도구로 페이지의 소스를 살펴봅니다. 12&lt;a href=\"http://futurecreator.github.io\"&gt;내 홈페이지&lt;/a&gt;&lt;a href=\"http://www.naver.com\" rel=\"external nofollow\" target=\"_blank\"&gt;네이버&lt;/a&gt; 그냥 링크만 넣어도 외부링크에 nofollw 속성이 추가되는 것을 확인할 수 있습니다. futurecreator.github.io 는 제 도메인이기 때문에 추가되지 않았습니다. hexo-auto-canonical &lt;meta&gt; 태그 중 canonical 속성은 대표 URL (선호 URL) 을 나타냅니다. 동일 콘텐츠를 여러개의 URL로 표현이 가능할 경우 가장 선호되는 대표 URL을 지정하는 것이 바로 대표 URL 입니다. 중복되거나 비슷한 콘텐츠에 대한 링크를 통합해서 같은 주제에 통계를 내기가 쉽고 사용자가 검색을 통해 페이지에 방문하기에 유리합니다. 각 포스트마다 설정해주는 것이 귀찮기 때문에 자동으로 생성해주는 플러그인을 사용해보죠. 설치1$ npm install --save hexo-auto-canonical 사용이제 &lt;head&gt; 태그 안에 대표 URL 속성을 집어넣어야겠죠? head.ejs 안에 다음 코드를 넣으면 generate 할 때 코드를 생성해줍니다. 파일 중간 쯤에 &lt;%- meta(page) %&gt; 라고 있는데 그 바로 아래 붙여넣으시면 됩니다. 1&lt;%- autoCanonical(config, page) %&gt; 개발자 도구를 통해 소스를 살펴보면 &lt;head&gt; 태그에 cononical 속성이 추가된 것을 확인할 수 있습니다. 1&lt;link rel=\"canonical\" href=\"http://futurecreator.github.io/2016/06/19/hexo-tag-plugins/\"&gt; hexo-generator-seo-friendly-sitemap검색엔진이 우리 사이트의 전체적인 구조를 알 수 있도록 사이트맵 XML 파일을 제출하면 크롤러가 우리 페이지를 더 효율적으로 크롤링할 수 있습니다. 구글에서 sitemap generator 를 검색해보면 여러가지 온라인 툴들이 나오지만 번거롭게 그럴 필요가 없이 플러그인을 통해 자동으로 생성해보겠습니다. 설치1$ npm install hexo-generator-seo-friendly-sitemap --save 사용_config.yml 에 다음과 같이 설정을 추가합니다. _config.yml123# sitemap auto generatorsitemap: path: sitemap.xml 옵션 설명 path 사이트맵 생성 경로를 지정합니다. 결과path 값을 sitemap.xml 이라고 지정했기 때문에 root 폴더에 sitemap.xml 이 생성됩니다. 제 사이트를 예로 들면 http://futurecreator.github.io/sitemap.xml 경로로 확인할 수 있습니다. 이제 배포하신 후에 Search Console 에서 구글에 사이트맵을 제출하시면 됩니다. 구글(Goolge) 사이트 등록(Search Console)과 검색엔진 최적화(SEO) hexo-generator-feedRSS feed 는 사이트내의 최신 콘텐츠를 담고 있는 파일입니다. 등록한 사이트에서 새 글이 올라오면 바로 읽을 수 있는 RSS feed Reader 를 생각해보시면 되겠습니다. 이 또한 검색엔진에 제출할 수 있죠. 플러그인을 이용해서 자동 생성하겠습니다. 설치1$ npm install hexo-generator-feed --save 설정_config.yml123456# rss feed auto generatorfeed: type: atom path: feed.xml limit: 20 hub: 옵션 설명 type feed 타입 설정 (atom/rss2) path feed 파일을 저장할 경로 (기본값 atom.xml/rss2.xml) limit 최신 포스트의 갯수 설정. (0 또는 false 입력 시 전체 포스트) 결과그러면 root 경로에 feed.xml 이 생긴 것을 확인하실 수 있습니다. Related Posts 워드프레스보다 쉬운 Hexo 블로그 시작하기 구글(Goolge) 사이트 등록(Search Console)과 검색엔진 최적화(SEO) 네이버 사이트 등록(웹마스터 도구)과 검색엔진 최적화(SEO) Hexo 블로그에 구글 애드센스(Adsense) 추가하기 오픈 그래프 (Open Graph) 태그와 페이스북 도메인 인사이트 (Domain Insight) 구글(Google) 검색 원리와 검색이 잘 되게 하는 방법 검색 엔진 최적화(SEO)에 유용한 Hexo 플러그인 구글 검색 상위 노출을 위한 200가지 팁","categories":[{"name":"Web","slug":"Web","permalink":"http://futurecreator.github.io/categories/Web/"},{"name":"Hexo","slug":"Web/Hexo","permalink":"http://futurecreator.github.io/categories/Web/Hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://futurecreator.github.io/tags/hexo/"},{"name":"seo","slug":"seo","permalink":"http://futurecreator.github.io/tags/seo/"},{"name":"plugins","slug":"plugins","permalink":"http://futurecreator.github.io/tags/plugins/"}]},{"title":"Hexo 에 Github 저장소 타임라인 (Repository timeline) 정보 추가하기","slug":"add-github-repository-timeline-badge-to-hexo","date":"2016-06-22T09:04:19.000Z","updated":"2016-06-23T07:19:46.000Z","comments":true,"path":"2016/06/22/add-github-repository-timeline-badge-to-hexo/","link":"","permalink":"http://futurecreator.github.io/2016/06/22/add-github-repository-timeline-badge-to-hexo/","excerpt":"","text":"이전 포스트에서 github 유저 혹은 리파지토리의 정보를 가지고 있는 네임카드를 Hexo 블로그에 달아봤습니다. 저는 사이드바에 달아서 지금 블로그를 보시면 네임카드를 확인해보실 수 있습니다. Github 관련 유용한 플러그인이 하나 또 있어서 추천드리려고 합니다. Hexo 네임카드 추가하기 (Github Card) hexo-github 플러그인IT 혹은 프로그래밍 관련 포스팅을 하다보면 예제 소스를 많이 사용하게 되고, Github 에 예제 소스를 올려놓고 참고하는 방식을 사용합니다. 그런데 만약 포스팅을 한 이후에 해당 리파지토리에 변화가 생긴다면 어떨까요? 계속 수정과 커밋을 반복하면서 이전 소스와 많이 달라진다면, 해당 포스트에 가서 커밋버전을 적어놓거나 수정을 해야할 겁니다. hexo-github 는 이런 문제를 해결할 수 있는 플러그인입니다. 해당 리파지토리의 커밋버전과 실시간 타임라인 정보를 뱃지 형태로 보여줍니다. 반응형이라 꽤 이쁘게 동작하네요. 클릭하면 해당 커밋 버전의 소스 페이지로 이동합니다. 설치Hexo 설치한 폴더에서 다음 명령어로 플러그인을 설치합니다. 1npm install hexo-github --save 사용법1&#123;% github user repo referenced_commit [auto_expand = true | false] [width = 100%] %&#125; 태그 플러그인 형식으로 동작합니다. 태그 플러그인은 코드를 쉽게 삽입하는 Hexo 의 문법이라고 보시면 되겠습니다. ([] 로 표시되어 있는 옵션은 필수값이 아닙니다.) Hexo 태그 플러그인 (Tag plugins) 살펴보기 옵션 설명 user GitHub 유저 이름 repo GitHub 유저의 리파지토리 이름 commit 커밋 버전 (SHA). full SHA 가 아니더라도 가능합니다. auto_expand 타임라인이 처음부터 확장된 채로 표시됩니다. 따라서 sync 는 처음 열릴 때 한번만 수행됩니다. true 또는 false. (Optional, 기본값은 false) width 위젯의 넓이. 유효한 CSS 값이면 입력 가능합니다. (Optional, 기본값은 100%) 결과1&#123;% github futurecreator SpringBootGetStarted eb86ae0 %&#125; loadStyle(\"/hexo-github/style.css\"); loadStyle(\"/hexo-github/octicons/octicons.css\"); new Badge(\"#badge-container-futurecreator-SpringBootGetStarted-eb86ae0\", \"futurecreator\", \"SpringBootGetStarted\", \"eb86ae0\", false); HelloController.java1234567891011121314@Controllerpublic class HelloController &#123; @RequestMapping(\"/hello\") public String hello(Model model, @RequestParam(value = \"name\", defaultValue = \"Unknown\", required = false) String name) &#123; String greetings = \"Hello, \" + name + \"!\"; model.addAttribute(\"greetings\", greetings); return \"hello\"; &#125;&#125; 해당 커밋버전이 잘 표시되네요. github 에 소스를 올려놓고 하는 포스팅에는 무조건 써야겠습니다. Hexo 추천 플러그인 포스트를 작성 중인데 양이 너무 많아서 한꺼번에는 힘들고 한두개씩 계속 올릴 예정입니다. 제가 직접 사용해보고 유용한 플러그인을 소개하도록 하겠습니다. Related Posts 워드프레스보다 쉬운 Hexo 블로그 시작하기 Hexo 추천 테마, Hueman 적용하기 Hexo 기본 사용법 Hexo 태그 플러그인 (Tag plugins) 살펴보기 Hexo 네임카드 추가하기 (Github Card) Hexo 에 Github 저장소 타임라인 (Repository timeline) 정보 추가하기 Hexo 블로그에 구글 애드센스(Adsense) 추가하기","categories":[{"name":"Web","slug":"Web","permalink":"http://futurecreator.github.io/categories/Web/"},{"name":"Hexo","slug":"Web/Hexo","permalink":"http://futurecreator.github.io/categories/Web/Hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://futurecreator.github.io/tags/hexo/"},{"name":"github","slug":"github","permalink":"http://futurecreator.github.io/tags/github/"},{"name":"plugins","slug":"plugins","permalink":"http://futurecreator.github.io/tags/plugins/"},{"name":"repository","slug":"repository","permalink":"http://futurecreator.github.io/tags/repository/"}]},{"title":"Hexo 네임카드 추가하기 (Github Card)","slug":"add-github-card-to-hexo","date":"2016-06-21T08:25:34.000Z","updated":"2016-06-23T07:20:26.000Z","comments":true,"path":"2016/06/21/add-github-card-to-hexo/","link":"","permalink":"http://futurecreator.github.io/2016/06/21/add-github-card-to-hexo/","excerpt":"","text":"Github Card 블로그에 저런 네임카드를 넣고 싶었는데 마땅한 걸 못찾아서 그냥 About 페이지에 About.me 페이지를 연결했습니다. 드디어 괜찮은 걸 찾았네요. Github Card 는 Github 의 네임 카드를 만들어주는 모듈입니다. 사이트에 가서 username 을 넣으면 유저 네임카드를 자동으로 생성해줍니다. 혹은 username/repository name 이렇게 넣으시면 해당 repository 의 네임카드를 만들 수도 있습니다. 테마는 2가지가 있습니다. 위에 보신 것이 default 이고 아래는 medium 테마입니다. 12&lt;div class=\"github-card\" data-github=\"futurecreator\" data-width=\"400\" data-height=\"\" data-theme=\"default\"&gt;&lt;/div&gt;&lt;script src=\"//cdn.jsdelivr.net/github-cards/latest/widget.js\"&gt;&lt;/script&gt; 생성을 하면 코드가 자동으로 생성되는데요, 이 코드를 복사해서 원하시는 곳에 넣으면 됩니다. 속성을 원하시는대로 변경하실 수도 있습니다. 속성 설명 user GitHub 유저 네임 repo GitHub 리파지토리 네임 width 카드 가로 크기 (기본값 400) height 카드 세로 크기 (기본값 200) theme 테마 (default 또는 mideum) target 링크를 새 탭에서 열게 하려면 값을 공백 (“”)으로 설정 Hexo 에 적용하기이제 Hexo 에 적용해보겠습니다. 저는 사이드바 (Sidebar) 부분 상단에 넣으려고 합니다. Hueman 테마 기준으로 사이드바의 레이아웃은 Sidebar.ejs 에서 정의합니다. sidebar.ejs1234567891011121314151617181920212223242526272829&lt;aside id=\"sidebar\"&gt; &lt;a class=\"sidebar-toggle\" title=\"Expand Sidebar\"&gt;&lt;i class=\"toggle icon\"&gt;&lt;/i&gt;&lt;/a&gt; &lt;div class=\"sidebar-top\"&gt; &lt;p&gt;&lt;%= __('sidebar.follow') %&gt;:&lt;/p&gt; &lt;ul class=\"social-links\"&gt; &lt;% for (var i in theme.customize.social_links) &#123; %&gt; &lt;% if (theme.customize.social_links[i]) &#123; %&gt; &lt;li&gt; &lt;a class=\"social-tooltip\" title=\"&lt;%= i %&gt;\" href=\"&lt;%- url_for(theme.customize.social_links[i]) %&gt;\" target=\"_blank\"&gt; &lt;i class=\"icon fa fa-&lt;%= i %&gt;\"&gt;&lt;/i&gt; &lt;/a&gt; &lt;/li&gt; &lt;% &#125; %&gt; &lt;% &#125; %&gt; &lt;/ul&gt; &lt;/div&gt; &lt;!-- github card 넣을 자리 --&gt; &lt;% if (is_post()) &#123; %&gt; &lt;%- partial('post/nav', &#123;post: page&#125;) %&gt; &lt;% &#125; %&gt; &lt;div class=\"widgets-container\"&gt; &lt;% if (theme.widgets) &#123; %&gt; &lt;% theme.widgets.forEach(function(widget) &#123; %&gt; &lt;%- partial('widget/' + widget) %&gt; &lt;% &#125;) %&gt; &lt;% &#125; %&gt; &lt;/div&gt; &lt;%- partial('custom_ad/adsense') %&gt;&lt;/aside&gt; 보시면 사이드바 상단에 토글버튼, 소셜링크 아이콘이 출력되는걸 볼 수 있습니다. 그 다음에 각종 위젯이 나오는데 그 바로 위에 넣겠습니다. 그리고 width 속성값이 기본적으로 400 으로 되어있는데 이 값을 주지 않으면 상위 &lt;div&gt; 에 맞춰서 표시됩니다. 지금 제 블로그의 사이드바를 보시면 적용된 것을 바로 확인하실 수 있습니다. Hexo 플러그인 활용하기Hexo 에 Github Card 를 자동생성 해주는 플러그인 이 존재합니다. 태그 플러그인 으로 본문 상에 Github Card 를 쉽게 출력할 수 있습니다. Hexo 태그 플러그인에 대해 궁금하신 분들은 이전 포스트를 참고하시기 바랍니다. Hexo 태그 플러그인 (Tag plugins) 살펴보기 설치1$ npm install --save hexo-github-card 사용태그 플러그인으로 본문 상에 다음과 같은 코드를 작성하면 됩니다. 그러면 해당 위치에 네임카드가 삽입됩니다. 1&#123;% githubCard user [repo] [width = 400] [theme] %&#125; 사용할 수 있는 옵션은 다음과 같습니다. 옵션 설명 user GitHub 유저 네임 repo GitHub 리파지토리 네임 width 카드 가로 크기 (기본값 400) theme 테마 (default 또는 mideum) Github Card 를 이용해서 Hexo 블로그에 네임카드를 넣어봤습니다. 핸드폰이나 PC 에서도 크기에 따라 잘 나오네요. 다음 포스트에서는 Github card plugin 처럼 유용한 Hexo plugin 을 살펴보겠습니다. Related Posts 워드프레스보다 쉬운 Hexo 블로그 시작하기 Hexo 추천 테마, Hueman 적용하기 Hexo 기본 사용법 Hexo 태그 플러그인 (Tag plugins) 살펴보기 Hexo 네임카드 추가하기 (Github Card) Hexo 에 Github 저장소 타임라인 (Repository timeline) 정보 추가하기","categories":[{"name":"Web","slug":"Web","permalink":"http://futurecreator.github.io/categories/Web/"},{"name":"Hexo","slug":"Web/Hexo","permalink":"http://futurecreator.github.io/categories/Web/Hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://futurecreator.github.io/tags/hexo/"},{"name":"github","slug":"github","permalink":"http://futurecreator.github.io/tags/github/"},{"name":"namecard","slug":"namecard","permalink":"http://futurecreator.github.io/tags/namecard/"}]},{"title":"Hexo 기본 사용법","slug":"hexo-basic-usage","date":"2016-06-20T15:59:57.000Z","updated":"2016-08-17T14:04:37.000Z","comments":true,"path":"2016/06/21/hexo-basic-usage/","link":"","permalink":"http://futurecreator.github.io/2016/06/21/hexo-basic-usage/","excerpt":"","text":"Hexo 는 이전 포스트 에서 알아본 간단한 커맨드만 있어도 충분히 사용 가능합니다. 하지만 Hexo 는 편하게 블로깅할 수 있는 여러가지 기능을 제공합니다. 이번 포스트에서는 기본적인 사용법을 좀 더 자세히 알아보겠습니다. 알아볼 기능들은 다음과 같습니다. 스캐폴딩을 기반으로 초안을 생성 본문을 작성할 때 사용할 수 있는 태그 플러그인 작성을 완료한 후에 퍼블리쉬 자원은 전역/ 포스트 폴더에서 관리 로컬 서버에서 테스트 정적 파일 생성과 배포 포스팅하기 (Writing)마크다운 파일 생성하기마크다운을 작성할 파일을 만드는 것부터 시작합니다. 다음 명령어를 통해 작성할 마크다운 파일이 해당 경로에 생성됩니다. 1$ hexo new [layout] &lt;title&gt; layout : 기본 레이아웃은 3가지 종류가 있고 각기 다른 경로에 보관됩니다. post page draft layout 을 생략할 경우 post 로 생성됩니다. title : 파일 제목을 입력합니다. 레이아웃 (Layout) 레이아웃 파일 경로 post source/_posts page source draft source/_drafts 포스트 (Post)홈페이지에 게시가 되는 기본적인 글입니다. 블로그에 새 글을 작성하는 것이라고 볼 수 있습니다. 기본 레이아웃이라서 레이아웃 종류를 입력하지 않아도 포스트로 자동 인식합니다. 기본 레이아웃은 _config.yml 의 default_layout 항목에서 변경 가능합니다. 페이지 (Page)포스트처럼 새 글을 추가하는 것이 아니라 해당 경로로 접근해야 볼 수 있는 페이지를 작성할 때 사용합니다. 초안 (Draft)draft 는 바로 게시하지 않고 작성할 수 있는 초안입니다. 따라서 포스트를 작성할 때 먼저 초안으로 작성하고, 다 작성한 후에 publish 명령어로 배포하는 형식으로 게시할 수 있습니다. 여러 개의 포스트를 작성 중일 때, 바로 반영 안할 포스트는 로컬에 따로 저장해놨다가 나중에 복붙하는 작업이 귀찮았는데 그럴 필요가 없었군요. 저는 초안을 자주 사용해서 draft 를 기본 레이아웃으로 변경했습니다. _config.yml 의 default_layout 을 draft 로 변경하면, hexo new &lt;title&gt; 로 생성했을 때 포스트가 아닌 드래프트가 만들어집니다. 하지만 작업하면서 실제 화면에서 어떻게 보일지 궁금합니다. 로컬 서버 돌릴 때 --draft 옵션을 주면 로컬서버에서 draft 로 작성한 것도 확인할 수 있습니다. 1$ hexo server --draft 매번 이렇게 실행하는 것이 귀찮으시다면, _config.yml 파일에서 render_drafts 항목을 true 로 주시면 됩니다. 하지만 이 경우에는 원격 서버에도 초안이 드러나기 때문에 굳이 이렇게 설정할 필요는 없을 것 같네요. _config.yml12# Writingrender_drafts: true 파일명1$ hexo new [layout] &lt;title&gt; 여기서 입력하는 title 이 기본적으로 파일명이 됩니다. 파일명이 곧 페이지의 url 이 되기 때문에 파일명은 본문 내용의 핵심 키워드를 조합해서 만드는 것이 좋습니다. 그래야 검색에 잘 노출되기 때문이죠. 1$ hexo new post &apos;test page&apos; 위와 같은 명령어를 치면, test-page.md 라는 파일이 생성됩니다. 만약 날짜로 prefix 를 붙이고 싶다면 :year:month:day-:title.md 이런 식으로 placeholder 를 이용해서 커스터마이징 할 수 있습니다. 제가 현재 사용하는 방법인데 앞에 날짜가 붙어 있으면 날짜 별로 구분할 수 있어서 좋습니다. _config.yml12# Writingnew_post_name: :year:month:day-:title.md 사용할 수 있는 placeholder 는 다음과 같습니다. Placeholder 설명 :title 포스트 제목 (소문자만 가능, 공백 (space)은 하이픈 (-)으로 변경됨) :year 생성 연도, e.g. 2015 :month 생성 월 (0 포함), e.g. 04 :i_month 생성 월, e.g. 4 :day 생성 날짜 (0 포함), e.g. 07 :i_day 생성 날짜, e.g. 7 스캐폴드 (Scaffolds)스캐폴드는 사전에서 찾아보면 ‘높은 곳에서 공사를 할 수 있도록 임시로 설치한 가설물’ 이라고 나옵니다. 즉, 포스트, 페이지, 드래프트를 만들 때 처음에 나오는 구조를 정의하는 파일입니다. 물론 커스텀 스캐폴드를 만들어서 사용할 수도 있겠죠. /scaffolds/post.md12345---title: &#123;&#123; title &#125;&#125;date: &#123;&#123; date &#125;&#125;tags:--- 기본적으로 이렇게 되어있죠. 그래서 포스트를 생성하면 이런 형식으로 나오게 됩니다. 제가 사용하는 방식은 다음과 같습니다. /scaffolds/post.md1234567891011---title: &#123;&#123; title &#125;&#125;date: &#123;&#123; date &#125;&#125;categories: -tags: -thumbnail:---### Related Posts 카테고리를 항상 추가하기 때문에 여기에 직접 넣었습니다. 사용할 수 있는 placeholder 는 다음과 같습니다. 기능이 다양하진 않지만 그냥 처음 생성되는 파일의 레이아웃을 정한다고 생각하시면 되겠습니다. Placeholder 설명 layout 레이아웃 title 제목 date 파일 생성 일자 Front-matterFront-matter 는 포스트 최상단에 있는 블락으로 해당 파일의 정보를 입력하는 곳입니다. 이미 앞에서 보셨듯이 --- 로 구분되어져 있는 블락입니다. YAML 이나 JSON 으로 설정 가능한데 그냥 기본적인 YAML 로 사용하겠습니다. 1234---title: Hello Worlddate: 2013/7/13 20:46:25--- 설정생각보다 여러가지 기능이 있습니다. 많이 사용하시는 것들은 스캐폴드에 정의해놓으시면 편하게 사용하실 수 있습니다. 설정 설명 기본값 layout 레이아웃 title 제목 date 배포한 날짜 파일 생성 날짜 updated 수정된 날짜 파일 생성 날짜 comments 코멘트 기능 여부 true tags 태그 (Page 에서는 사용 불가) categories 카테고리 (Page 에서는 사용 불가) permalink 포스트의 URL 을 수동으로 설정 가능 thumbnail 썸네일 지정 본문 첫번째 이미지 카테고리와 태그카테고리와 태그는 Post 와 Draft 에서만 사용 가능합니다. 여기서 카테고리를 지정하면 메인 화면의 메뉴에 자동으로 추가됩니다. 카테고리는 여러개를 지정할 경우 아래에 있는게 서브카테고리가 됩니다. 태그는 그냥 여러개 설정하셔도 됩니다. 여러개 설정할 경우 다음과 같이 작성하시면 됩니다. 1234567categories:- Web- Hexotags:- hexo- blog- famework 태그 플러그인 (Tag Plugins)태그 플러그인은 쉽게 포스트를 적성하기 위한 Hexo 자체적인 문법입니다. 자동 코드 생성 문법이라고 할 수 있죠. 양이 방대해서 따로 포스트를 작성했으니 참고하기 바랍니다. Hexo 태그 플러그인 (Tag plugins) 살펴보기 자원 폴더 (Asset Folders)자원 폴더는 해당 포스트에서 사용하는 여러가지 자원 즉 이미지, 동영상, 링크 등을 저장하는 폴더입니다. Hexo 는 source 상에 있는 자원을 가지고 public 폴더를 생성합니다. public 폴더가 실제 서버에 올라가는 폴더입니다. 그렇다고 public 폴더에 자원을 추가하면 안됩니다. public 폴더는 generate 할 때마다 새롭게 생성되기 때문이죠. 따라서 자원은 source 폴더 내에서 관리해야 합니다. 전역 자원 폴더 (Global Asset Folders)전역 자원 폴더는 /source/에 있는 폴더입니다. 여기에 폴더를 만들어서 접근할 수 있습니다. 예를 들어 /source/images 라는 폴더를 생성하면 소스 내에서 /images/ 경로로 바로 접근이 가능합니다. 어느 포스트나 동일하게 사용이 가능합니다. 포스트 자원 폴더 (Post Asset Folders)모든 자원을 전역 폴더 하나에서 관리하기보다 포스트마다 각각 폴더를 만들어 관리하는 방법도 있습니다. _config.yml12# Writingpost_asset_folder: true 위와 같이 _config.yml 에서 설정을 변경하면 $ hexo new [layout] &lt;title&gt; 커맨드로 새 글을 생성할 때마다 함께 폴더가 생성됩니다. 그러면 그 폴더 안에 이미지 등을 넣고 절대 경로가 아닌 상대경로로 바로 접근 가능합니다. 기존에 /images/~~/example.png 라고 접속했다면, 이제는 ‘example.png’ 라고 바로 접근할 수 있게 됩니다. 1![](example.png) 테스트 해보면 잘 되실겁니다. 하지만 문제는 그냥 포스트 상에서는 되지만 카테고리, 태그, 어카이브 등으로 해당 포스트를 접속할 경우 url 이 달라져서 이미지에 접근이 안됩니다. 이럴 때는 마크다운 문법으로 접근하면 안되고 태그 플러그인 포스트 에서 살펴봤던 자원 삽입 태그를 이용해야 합니다. 123&#123;% asset_path slug %&#125;&#123;% asset_img slug [title] %&#125;&#123;% asset_link slug [title] %&#125; 따라서 위의 예제는 이렇게 해야 제대로 나옵니다. 1&#123;% asset_img example.png Example %&#125; 그래서 여러 포스트에서 공통적으로 사용할 이미지는 전역 폴더에, 포스트 상에서만 사용할 경우는 포스트 폴더에 저장해서 활용하시면 되겠습니다. 로컬 서버 (Server)로컬 서버는 리파지토리에 push 하기 전에 어떻게 표시되는지 확인하는 용도로 사용됩니다. 로컬 서버는 기본적으로 Hexo 패키지에 포함되어 설치되는데, 만약 설치되어있지 않을 경우, 다음과 같은 명령어로 설치가 가능합니다. 1$ npm install hexo-server --save 로컬 서버는 다음과 같이 기동합니다. 123$ hexo serverINFO Start processingINFO Hexo is running at http://localhost:4000/. Press Ctrl+C to stop. http://localhost:4000/ 으로 접속하면 로컬 서버 기동된 것을 확인할 수 있습니다. server 명령어에 지정할 수 있는 옵션은 다음과 같습니다. 옵션 설명 기본값 -i, –ip 서버 IP 지정합니다. 0.0.0.0 -p, –port 포트 번호를 지정합니다. 4000 -s, –static 정적 (static) 파일만 게시합니다. false -l, –log 서버로그를 표시합니다. false -o, –open 서버 기동과 동시에 브라우저 창으로 접속합니다. false –draft 초안도 게시합니다. false 정적 파일 생성 (Generating)서버에 배포하기 전에 정적 파일을 최신버전으로 생성해야 합니다. 다음 명령어로 간단하게 생성할 수 있습니다. 1$ hexo generate --watch 옵션을 사용하면 실시간으로 파일을 생성할 수 있습니다. 계속 돌아가면서 파일 변화가 있으면 즉시 생성합니다. 1$ hexo generate --watch 하나의 명령어로 생성과 배포를 이어서 할 수 있습니다. 1$ hexo generate --deploy 혹은 1$ hexo deploy --generate 위와 같은 명령어로 실행할 수 있습니다. 두 명령어는 동일한 기능을 수행합니다. 이 명령어는 다음과 같이 더 줄일 수 있습니다. 12$ hexo generate -d$ hexo deploy -g 배포 (Deployment)로컬에서 작성한 내용들을 원격 서버로 올려 실제로 반영하기 위한 작업을 배포 (Deployment) 라고 합니다. 다음 명령어로 배포할 수 있습니다. 1$ hexo deploy 원격 서버에 배포하기 위해서는 원격 서버를 미리 설정해야 합니다. 앞선 포스트에서 모두 Git 을 기준으로 작성했기 때문에 배포도 Git 서버를 기준으로 설명하겠습니다. 먼저 Git 서버 배포 플러그인을 설치합니다. 1$ npm install hexo-deployer-git --save _config.yml 을 수정합니다. _config.yml12345deploy: type: git repo: &lt;repository url&gt; branch: [branch] message: [message] 사용할 수 있는 옵션은 다음과 같습니다. 옵션 설명 repo GitHub 리파지토리 URL branch 브랜치 이름. 브랜치 이름은 자동으로 설정된다. message 커밋 메시지 설정 Hexo 에 다양한 기능을 살펴봤습니다. 스캐폴딩을 기반으로 초안을 생성 본문을 작성할 때 사용할 수 있는 태그 플러그인 작성을 완료한 후에 퍼블리쉬 자원은 전역/ 포스트 폴더에서 관리 로컬 서버에서 테스트 정적 파일 생성과 배포 다음 포스트에서는 유용한 Hexo 플러그인 패키지를 살펴보겠습니다. Related Posts 워드프레스보다 쉬운 Hexo 블로그 시작하기 Hexo 추천 테마, Hueman 적용하기 Hexo 기본 사용법 Hexo 태그 플러그인 (Tag plugins) 살펴보기 Hexo 네임카드 추가하기 (Github Card) Hexo 에 Github 저장소 타임라인 (Repository timeline) 정보 추가하기 구글(Goolge) 사이트 등록(Search Console)과 검색엔진 최적화(SEO) 네이버 사이트 등록(웹마스터 도구)과 검색엔진 최적화(SEO) Hexo 블로그에 구글 애드센스(Adsense) 추가하기 오픈 그래프 (Open Graph) 태그와 페이스북 도메인 인사이트 (Domain Insight) 구글(Google) 검색 원리와 검색이 잘 되게 하는 방법 검색 엔진 최적화(SEO)에 유용한 Hexo 플러그인","categories":[{"name":"Web","slug":"Web","permalink":"http://futurecreator.github.io/categories/Web/"},{"name":"Hexo","slug":"Web/Hexo","permalink":"http://futurecreator.github.io/categories/Web/Hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://futurecreator.github.io/tags/hexo/"},{"name":"basic","slug":"basic","permalink":"http://futurecreator.github.io/tags/basic/"},{"name":"usage","slug":"usage","permalink":"http://futurecreator.github.io/tags/usage/"}]},{"title":"Mac 과 Windows 에 MySQL (MariaDB) 설치하기","slug":"mysql-mariadb-isntall-settings-mac-windows","date":"2016-06-20T02:22:03.000Z","updated":"2016-06-23T07:23:28.000Z","comments":true,"path":"2016/06/20/mysql-mariadb-isntall-settings-mac-windows/","link":"","permalink":"http://futurecreator.github.io/2016/06/20/mysql-mariadb-isntall-settings-mac-windows/","excerpt":"","text":"DBMS (Database Management System)IT (Information Technology) 는 데이터를 가공해 사용자에게 유용한 정보를 제공하는 기술입니다. 따라서 데이터와 정보를 저장하는 DB 와 DB 를 관리하는 DBMS 야말로 IT의 기본이라고 할 수 있습니다. 스프링부트를 더 알아보기 전에 DB 구축을 하기 위한 DBMS 설치 및 설정을 알아보겠습니다. MySQL &amp; MariaDB MySQL은 독보적인 인기와 점유율을 가지고 있는 오픈소스 DBMS 였습니다. 그런데 SUN에 인수되고 오라클이 또 SUN을 인수하면서 지금은 상용 버전과 GPL 라이선스를 가진 커뮤니티 버전으로 나뉘어져 있습니다. 오라클은 점유율 1위의 자체적인 상용 DB 를 가지고 있기 때문에 MySQL 출신 개발자들이 나와서 MySQL을 기반으로 MariaDB 라는 DBMS를 만들었습니다. MariaDB 는 MySQL의 기반이기 때문에 MySQL 과 호환이 되고, 거기에 계속해서 업데이트를 하고 있습니다. MySQL 의 상위호환이 목표라고 할 수 있겠죠. DB 랭킹을 살펴보면 MariaDB의 점유율이 계속해서 높아지는 걸 볼 수 있습니다. Mac에서 MariaDB 설치하기이번 포스트에서는 MariaDB 로 진행해보겠습니다. Mac에서는 homebrew를 이용하면 쉽게 설치할 수 있습니다. 터미널에서 간단하게 설치가 가능하죠. 다운로드12brew updatebrew install mariadb 설치12unset TMPDIRmysql_install_db 실행1mysql.server start 서버 상태 확인1mysql.server status Windows에서 MariaDB 설치하기다운로드홈페이지 에서 zip 파일을 다운받아 압축을 풉니다. 설치1mysql_install_db.exe --datadir=C:\\db --service=MyDB --password=secret --datadir: 데이타 파일 경로 --service: MariaDB를 서비스로 등록할 이름 --password: 접속 비밀번호 실행설정한 서비스 이름으로 시작합니다. 1sc start MyDB 접속하기처음에는 root 계정으로 접속합니다. 1mysql -uroot 데이터베이스 조회1SHOW DATABASES; MySQL/ MariaDB 초기 설정사용하기 전에 몇 가지 설정이 필요합니다. UTF-8 설정하기한글이 깨지지 않고 잘 나오게 하려면 기본적인 character encoding 설정을 utf-8으로 변경해야 합니다. /etc/my.cnf 파일을 만들고 다음 내용을 작성합니다. DBMS를 재시작하면 적용됩니다. 123456789101112[mysqld]character-set-server=utf8collation-server=utf8_general_ciinit_connect=SET collation_connection=utf8_general_ciinit_connect=SET NAMES utf8[client]default-character-set=utf8[mysql]default-character-set=utf8 DB 생성하기TESTDB 라는 이름으로 테스트용 DB를 만들어봅시다. 1CREATE DATABASE TESTDB; 잘 만들어졌는지 확인해보겠습니다. 1SHOW DATABASES; 계정 설정하기root 계정은 시스템 계정이므로 테스트할 DB 인 testdb만 사용 가능하도록 개발용 계정을 만들어야 합니다. 먼저 root 계정으로 접속을 합니다. 1mysql -u root 먼저 mysql 이라는 서버로 변경합니다. 12345$ MariaDB [(none)]&gt; USE mysql;Reading table information for completion of table and column namesYou can turn off this feature to get a quicker startup with -ADatabase changed mysql 데이터베이스의 user 테이블을 조회하면 사용자 목록을 볼 수 있습니다. 1234567891011$ MariaDB [mysql]&gt; SELECT User, Host from user;+------------------+-----------+| User | Host |+------------------+-----------+| root | 127.0.0.1 || root | ::1 || | localhost || debian-sys-maint | localhost || root | localhost |+------------------+-----------+5 rows in set (0.00 sec) localhost로만 접속 가능한 dev 사용자를 만들어봅시다. 비밀번호는 ‘init0000’ 으로 했는데 원하시는 비밀번호로 하시면 됩니다. 12$ MariaDB [mysql]&gt; CREATE USER dev@localhost IDENTIFIED BY &apos;init0000&apos;;Query OK, 0 rows affected (0.00 sec) dev@localhost 계정에 TESTDB의 테이블에 대한 권한을 부여합니다. 12$ MariaDB [mysql]&gt; GRANT ALL PRIVILEGES ON testdb.* TO dev@localhost;Query OK, 0 rows affected (0.00 sec) 권한 조회를 통해 확인할 수 있습니다. 12345678$ MariaDB [mysql]&gt; show grants for dev@localhost;+------------------------------------------------------------------------------------------------------------+| Grants for dev@localhost |+------------------------------------------------------------------------------------------------------------+| GRANT USAGE ON *.* TO &apos;dev&apos;@&apos;localhost&apos; IDENTIFIED BY PASSWORD &apos;*16B7154F725D3F83A3C7F5543E0EF82C5AFF0FF5&apos; || GRANT ALL PRIVILEGES ON `testdb`.* TO &apos;dev&apos;@&apos;localhost&apos; |+------------------------------------------------------------------------------------------------------------+2 rows in set (0.00 sec) 이제 dev 계정으로 접속해봅시다. 1mysql -u &lt;username&gt; -p &lt;password&gt; 여기서 패스워드 입력하지 않고 -p 만 입력하면 패스워드 입력하라고 한번 더 나오니까 그 때 입력하셔도 됩니다. 123456789$ handonghoui-MacBook-Pro:etc handongho$ mysql -u dev -pEnter password:Welcome to the MariaDB monitor. Commands end with ; or \\g.Your MariaDB connection id is 14Server version: 10.1.14-MariaDB HomebrewCopyright (c) 2000, 2016, Oracle, MariaDB Corporation Ab and others.Type &apos;help;&apos; or &apos;\\h&apos; for help. Type &apos;\\c&apos; to clear the current input statement. 로그인한 후, 데이베이스를 조회해보면 TESTDB 를 확인할 수 있습니다. 123456789MariaDB [(none)]&gt; show databases;+--------------------+| Database |+--------------------+| TESTDB || information_schema || test |+--------------------+3 rows in set (0.00 sec) 이제 테이블을 만들고 다른 애플리케이션을 통해 활용하면 되겠습니다. 다음 포스트에서는 스프링부트 에서 JPA 를 이용해 DB와 연결하고 데이터 다루는 방법을 살펴보겠습니다. Related Posts스프링 부트 (Spring Boot) 로 시작하는 프레임워크 (Framework)","categories":[{"name":"Spring","slug":"Spring","permalink":"http://futurecreator.github.io/categories/Spring/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://futurecreator.github.io/tags/mysql/"},{"name":"mariadb","slug":"mariadb","permalink":"http://futurecreator.github.io/tags/mariadb/"},{"name":"install","slug":"install","permalink":"http://futurecreator.github.io/tags/install/"},{"name":"settings","slug":"settings","permalink":"http://futurecreator.github.io/tags/settings/"},{"name":"mac","slug":"mac","permalink":"http://futurecreator.github.io/tags/mac/"},{"name":"windows","slug":"windows","permalink":"http://futurecreator.github.io/tags/windows/"}]},{"title":"Hexo 태그 플러그인 (Tag plugins) 살펴보기","slug":"hexo-tag-plugins","date":"2016-06-19T13:12:43.000Z","updated":"2016-08-17T14:01:58.000Z","comments":true,"path":"2016/06/19/hexo-tag-plugins/","link":"","permalink":"http://futurecreator.github.io/2016/06/19/hexo-tag-plugins/","excerpt":"","text":"Hexo 는 마크다운 외에 포스트를 작성하기 위한 자체적인 문법을 지원합니다. 그것을 태그 플러그인 이라고 합니다. 처음에는 마크다운이면 충분하지 않을까 싶어서 사용하지 않았었는데 유용한 기능들이 꽤 있더군요. 익숙해지시면 편하게 사용할 수 있는 태그 플러그인을 살펴보겠습니다. 인용 구문 (Block Quote)일반 마크다운 인용과는 다르게 작성자, 제목 등 여러가지 정보를 추가할 수 있습니다. 123&#123;% blockquote [author[, source]] [link] [source_link_title] %&#125;content&#123;% endblockquote %&#125; 일반 인용 (내용만)마크다운 문법의 &gt; 에 해당하는 형식입니다. 아무것도 쓰지 않을 때는 그냥 &gt; 를 쓰면 되겠습니다. 이 태그를 기반으로 작성자, 링크, 소스 타이틀 등 옵션을 추가할 수 있습니다. Example123&#123;% blockquote %&#125;마크다운 문법의 `&gt;` 에 해당하는 형식입니다. 아무것도 쓰지 않을 때는 그냥 `&gt;` 를 쓰면 되겠습니다. 이 태그를 기반으로 작성자, 링크, 소스 타이틀 등 옵션을 추가할 수 있습니다.&#123;% endblockquote %&#125; Result마크다운 문법의 &gt; 에 해당하는 형식입니다. 아무것도 쓰지 않을 때는 그냥 &gt; 를 쓰면 되겠습니다. 이 태그를 기반으로 작성자, 링크, 소스 타이틀 등 옵션을 추가할 수 있습니다. 책 인용 (저자 + 출처 제목)저자와 인용한 출처 두 가지만 적은 예시입니다. 책을 인용하는 경우가 이에 해당하겠습니다. 저자와 출처 사이에 구분할 수 있게 콤마 (,)를 넣어줘야 합니다. Example123&#123;% blockquote Amelie Nothomb, le voyage d&apos;hiver %&#125;사랑에는 실패가 없다.&#123;% endblockquote %&#125; Result사랑에는 실패가 없다. Amelie Nothomble voyage d'hiver 트위터 인용 (저자 + 출처 링크)저자와 출처의 링크 두 가지를 넣은 경우입니다. 출처에 링크가 걸려서 표시됩니다. 트위터에서 인용한 예시입니다. 트위터 내용은 @npmdaily 가 올린 npm package 중 하나로 Hexo 의 Keycap 추가하는 플러그인입니다. Example123&#123;% blockquote @npmdaily https://twitter.com/npmdaily/status/743858563299311616 %&#125;hexo-tag-kbd - Displays the keycaps in your hexo post/page. http://npmdaily.com/pkg/hexo-tag-kbd … #npm #javascript #nodejs&#123;% endblockquote %&#125; Resulthexo-tag-kbd - Displays the keycaps in your hexo post/page. http://npmdaily.com/pkg/hexo-tag-kbd … #npm #javascript #nodejs @npmdailytwitter.com/npmdaily/status/743858563299311616 웹 페이지 인용 (저자 + 출처 링크 + 출처 제목)저자와 출처 링크, 출처 제목까지 명시한 경우에는 링크가 출처 제목으로 표시됩니다. 웹 페이지를 인용할 경우 이런식으로 되겠습니다. Example123&#123;% blockquote Eric Han http://futurecreator.github.io/2016/06/14/get-started-with-hexo/ 워드프레스보다 쉬운 Hexo 블로그 시작하기%&#125;Hexo는 github pages를 이용한 블로그입니다. Github Pages 는 github 유저와 프로젝트의 정적인(static) 홈페이지를 자동으로 만들어주고 github.io 도메인으로 호스팅해주는 서비스입니다. 즉, 서버의 내용을 github 에 push만 하면 실시간 적용됩니다. 아주 간단하죠?&#123;% endblockquote %&#125; ResultHexo는 github pages를 이용한 블로그입니다. Github Pages 는 github 유저와 프로젝트의 정적인(static) 홈페이지를 자동으로 만들어주고 github.io 도메인으로 호스팅해주는 서비스입니다. 즉, 서버의 내용을 github 에 push만 하면 실시간 적용됩니다. 아주 간단하죠? Eric Han워드프레스보다 쉬운 Hexo 블로그 시작하기 코드 삽입아무래도 IT 블로그를 하다보면 소스코드를 많이 추가하게 됩니다. Hexo 에서는 여러가지 기능을 제공합니다. 소스의 제목, 언어, url, 링크 제목을 옵션으로 표시할 수 있습니다. 그리고 Hexo 는 highlight.js 를 사용해서 소스코드를 표시하기 때문에 highlight.js 를 이용하면 다양한 커스터마이징도 가능합니다. 123&#123;% codeblock [title] [lang:language] [url] [link text] %&#125;code snippet&#123;% endcodeblock %&#125; 일반 코드가장 기본적인 포맷이고 여기에 옵션이 추가됩니다. Example123&#123;% codeblock %&#125;alert(&apos;Hello World!&apos;);&#123;% endcodeblock %&#125; Result1alert(&apos;Hello World!&apos;); 언어 명시하기언어를 명시하는 경우입니다. 예시는 Objective-C 입니다. highlight.js 에서 지원하는 언어만 가능합니다. 지원가능한 언어는 155가지나 된다고 하네요. 자세한 내용은 highlightjs.org 에서 확인하세요. Example123&#123;% codeblock lang:objc %&#125;[rectangle setX: 10 y: 10 width: 20 height: 20];&#123;% endcodeblock %&#125; Result1[rectangle setX: 10 y: 10 width: 20 height: 20]; 캡션 추가하기예시처럼 파일명을 명시할 수 있겠네요. Example123&#123;% codeblock Array.map %&#125;array.map(callback[, thisArg])&#123;% endcodeblock %&#125; ResultArray.map1array.map(callback[, thisArg]) 캡션과 URL 추가하기Example1234&#123;% codeblock _.compact http://underscorejs.org/#compact Underscore.js %&#125;_.compact([0, 1, false, 2, &apos;&apos;, 3]);=&gt; [1, 2, 3]&#123;% endcodeblock %&#125; Result_.compactUnderscore.js12_.compact([0, 1, false, 2, &apos;&apos;, 3]);=&gt; [1, 2, 3] 마크다운 형식의 코드 블락마크다운 형식의 코드 블락 했을 때도 제목이나 링크 지정할 수 있었군요. 이렇게 쓰는게 제일 낫겠습니다.1``` [language] [title] [url] [link text] code snippet ``` Example1234```java test.javaString s = &quot;abc&quot;;System.out.println(s);``` Resulttest.java12String s = \"abc\";System.out.println(s); jsFiddlejsFiddle 은 온라인 상에서 HTML, CSS, javaScript 를 작성하고 테스트할 수 있는 서비스입니다. 1&#123;% jsfiddle shorttag [tabs] [skin] [width] [height] %&#125; shorttag: jsFiddle 에서 코드를 저장하면 대시보드에서 확인할 수 있는 코드 이름입니다. 그걸 입력하시면 알아서 불러옵니다. skin: theme 가 아니고 skin 입니다. 보시면 js, html, css, result 이렇게 네 가지 탭이 있는데 표시하고 싶은 것만 순서대로 나열하면 됩니다. Example1&#123;% jsfiddle pgtkkLsc html,result %&#125; Result GistGist 는 Github 에서 제공하는 서비스 중 하나로, 간단한 코드를 작성해서 공유할 수 있는 서비스입니다. 파일 이름, 코드, 코드 설명만 작성하면 바로 파일이 만들어지고 공유할 수 있습니다. 1&#123;% gist gist_id [filename] %&#125; gist_id: Gist 에서 코드를 생성한 후에 공유를 누르면 나오는 url 의 아이디 부분을 복사해서 넣으면 됩니다. Example1&#123;% gist 9a4aded78853db541ca2510d8d41e17f %&#125; Result iframe아이프레임 (iframe) &lt;iframe&gt; 은 내부 프레임(inline frame) 으로 HTML 문서 내에서 다른 HTML 을 표시하는 태그입니다. 1&#123;% iframe url [width] [height] %&#125; 내장 코드 삽입source/downloads/code 폴더 상에 있는 코드를 포스트에 삽입할 수 있습니다. 1&#123;% include_code [title] [lang:language] path/to/file %&#125; 유튜브 (YouTube)유튜브 비디오를 비디오 아이디만 있으면 바로 삽입 가능합니다. 1&#123;% youtube video_id %&#125; video_id: 유튜브에서 비디오 공유를 눌러서 나오는 url 의 뒷 부분이 해당 비디오의 고유한 아이디입니다. Example1&#123;% youtube c7rCyll5AeY %&#125; Result Vimeo비메오 (Vimeo) 도 유튜브와 동일하게 삽입 가능합니다. 1&#123;% vimeo video_id %&#125; video_id: 비메오에서 비디오 공유를 눌러서 나오는 url 의 뒷 부분이 해당 비디오의 고유한 아이디입니다. Example1&#123;% vimeo 167976188 %&#125; Result 포스트 삽입해당 블로그 내에 있는 포스트를 첨부할 수 있습니다. 굉장히 유용한 기능이네요! 따로 주소 복사해서 링크 만들지 않아도 됩니다. 12&#123;% post_path slug %&#125;&#123;% post_link slug [title] %&#125; slug: slug 는 포스트의 제목을 말합니다. Hexo 에서는 파일 제목이 url 이 되므로 포스트 파일 만들 때 사용한 파일명을 입력하면 됩니다. post_path: 포스트 제목을 입력하면 해당 포스트의 경로가 표시됩니다. post_link: 포스트 제목을 입력하면 해당 포스트의 링크가 생성됩니다. Example1&#123;% post_link get-started-with-hexo %&#125; Result워드프레스보다 쉬운 Hexo 블로그 시작하기 자원 (Asset) 삽입자원을 삽입하는 방법입니다. 이건 자원 폴더 (Asset folder) 와 관련이 있습니다. 해당 내용은 다음 포스트에서 다루도록 하겠습니다. Hexo 기본 사용법 123&#123;% asset_path slug %&#125;&#123;% asset_img slug [title] %&#125;&#123;% asset_link slug [title] %&#125; 나중에 필요할 때 찾아쓰시면 좋을 것 같네요. 다음 포스팅에서는 테마를 제작하고 커스터마이징할 때 필요한 변수와 Helper 를 알아보겠습니다. Related Posts 워드프레스보다 쉬운 Hexo 블로그 시작하기 Hexo 추천 테마, Hueman 적용하기 Hexo 기본 사용법 Hexo 태그 플러그인 (Tag plugins) 살펴보기 Hexo 네임카드 추가하기 (Github Card) Hexo 에 Github 저장소 타임라인 (Repository timeline) 정보 추가하기 구글(Goolge) 사이트 등록(Search Console)과 검색엔진 최적화(SEO) 네이버 사이트 등록(웹마스터 도구)과 검색엔진 최적화(SEO) Hexo 블로그에 구글 애드센스(Adsense) 추가하기 오픈 그래프 (Open Graph) 태그와 페이스북 도메인 인사이트 (Domain Insight) 구글(Google) 검색 원리와 검색이 잘 되게 하는 방법 검색 엔진 최적화(SEO)에 유용한 Hexo 플러그인","categories":[{"name":"Web","slug":"Web","permalink":"http://futurecreator.github.io/categories/Web/"},{"name":"Hexo","slug":"Web/Hexo","permalink":"http://futurecreator.github.io/categories/Web/Hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://futurecreator.github.io/tags/hexo/"},{"name":"plugin","slug":"plugin","permalink":"http://futurecreator.github.io/tags/plugin/"},{"name":"tag","slug":"tag","permalink":"http://futurecreator.github.io/tags/tag/"}]},{"title":"Postach.io, 에버노트 (Evernote)로 만드는 쉬운 블로그","slug":"evernote-blog-postach-io","date":"2016-06-19T08:19:55.000Z","updated":"2016-08-17T14:06:41.000Z","comments":true,"path":"2016/06/19/evernote-blog-postach-io/","link":"","permalink":"http://futurecreator.github.io/2016/06/19/evernote-blog-postach-io/","excerpt":"","text":"에버노트 (Evernote) 수없이 많은 메모 앱들 중에 최고는 에버노트 (Evernote)가 아닐까 합니다. ‘모든 장치들끼리 연동되는 노트’라는 컨셉으로 오랫동안 발전을 거듭해왔죠. 저 또한 2010년부터 지금까지 사용한 지 6년 정도 되었습니다. 그 시간만큼 쌓아온 자료들이 많아서 버릴 수가 없네요. 게다가 쓰면 쓸수록 의존도 높아져서 사용량도 많아졌습니다. 서비스 등급으로는 무료 등급 외에 에버노트 프리미엄 (월 5.99$, 연 49.99$)이 있습니다. 하지만 가격이 부담스럽기도 하고 무료 계정으로도 충분해서 필요성을 못느꼈는데, 에버노트 플러스 (월 $2.99, 연 24.99$) 라는 서비스 등급이 생겨났죠. 이미지를 많이 첨부할 경우에는 무료 계정으로는 조금 벅차서 현재는 플러스 등급을 사용하고 있습니다. Postach.io 그런데 에버노트로 블로그를 만들 수 있는 서비스가 있다고 해서 찾아봤습니다. 바로 Postach.io 라는 서비스입니다. 가입하면 postach.io 라는 도메인으로 호스팅되는 내 사이트가 만들어지고, 에버노트에 노트를 만들기만 하면 포스팅이 됩니다. 에버노트에 노트를 만들기만 하면 블로깅이 된다니! 생각만해도 엄청 편할 것 같군요. 당장 사용해보기로 했습니다. 회원 가입하기사이트 만들기 (Create site)Postach.io 에 접속해 회원 가입부터 합니다. 성, 이름, 이메일과 비밀번호 입력하면 끝! 노트북 연결하기 (Connect Notebook)바로 에버노트와 연동할 수 있는 창이 뜹니다. 에버노트에 로그인하고 인증을 수락하면 Postach.io 라는 노트북이 자동으로 생성됩니다. 구글이나 페북은 연동하고 나서 안쓰면 까먹고 관리가 안되는 편인데, 에버노트는 연동 시 기간을 설정할 수가 있습니다. 내가 사용하지 않아도 해당 기간이 지나면 자동으로 연동이 해지되겠네요. 포스팅 테스트하기 (Test Post) 그 다음은 포스트를 하나 생성해서 Postach.io 와 에버노트가 잘 연결되었는지 확인하는 단계입니다. 새로 생성된 Postach.io 노트북에 노트를 하나 만들고 published 라는 태그를 입력합니다. Postach.io 노트북에 있는 노트 중 published 라는 태그가 있는 것만 배포됩니다. 올리고 싶으면 태그를 붙이고, 내리고 싶으면 태그를 떼고. 간편하죠? 동기화 해야 반영되니, 태그까지 입력한 후 동기화하는 것도 잊지 마세요. 그러면 테스트 성공 화면이 나오면서 가입 절차가 마무리됩니다. 사이트 확인해보기이제 생성한 블로그 목록이 나옵니다. View 를 누르면 해당 사이트로 이동합니다. 기본 도메인은 username.postach.io 이고 username 부분은 변경이 가능합니다. 또는 커스텀 도메인으로도 등록할 수도 있습니다. 간단한 설정과 더불어 트위터, 페이스북, 구글플러스, 링크드인의 소셜링크 연결이 가능합니다. 기본 화면입니다. 프로필 사진과 백그라운드 이미지는 변경 가능합니다. 백그라운드 이미지가 엄청 큰 게 인상적인데 반해 유저 프로필 사진은 엄청 작네요. 포스트를 눌렀을 때 화면입니다. 모바일을 눌렀을 때 화면입니다. 장점먼저 장점부터 알아보겠습니다. 쉽다정말 쉽습니다. 에버노트에서 작성하고 published 태그만 붙이면 끝! 에버노트를 많이 사용하시는 분들이라면 정말 간편하게 블로그를 사용할 수 있습니다. 플러그인가장 핵심적이고 기본적인 플러그인 2개를 지원합니다. 구글 애넡리틱스: 다양한 기준으로 방문자 통계를 상세히 볼 수 있습니다. 디스커스: SNS 계정 (페이스북, 트위터 등)으로 포스트에 댓글을 달 수 있습니다. 구글 애널리틱스는 홈페이지에서 사이트를 등록하고 나오는 UA Code 를 입력하면 되고, 디스커스는 Disqus Shortname 만 넣으면 바로 홈페이지에 적용됩니다. 마크다운 지원블로깅하면 빼놓을 수 없는 마크다운 (Markdown) 문법도 지원합니다. 마크다운을 적용하려면 markdown 이라는 태그만 달면 됩니다. 검색 엔진 최적화 (SEO; Search Engine Optimization)홈페이지 설명에 검색 엔진 최적화가 되어있다고 하네요. 정말 그런지 확인해봐야곘네요. 12345678910111213141516171819202122232425262728293031&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt; Test | Eric's Site &lt;/title&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0\"&gt; &lt;meta name=\"mobile-web-app-capable\" content=\"yes\"&gt; &lt;meta name=\"apple-mobile-web-app-capable\" content=\"yes\"&gt; &lt;meta name=\"apple-mobile-web-app-status-bar-style\" content=\"black\"&gt; &lt;meta name=\"author\" content=\"Eric Han\"&gt; &lt;meta name=\"description\" content=\"This is a test.\"&gt; &lt;!-- OpenGraph tags --&gt; &lt;meta property=\"og:site_name\" content=\"Eric's Site\"&gt; &lt;meta property=\"article:published_time\" content=\"2016-06-19 04:32:46\"&gt; &lt;meta property=\"article:author\" content=\"Eric Han\"&gt; &lt;meta property=\"og:type\" content=\"article\"&gt; &lt;meta property=\"og:title\" content=\"Test\"&gt; &lt;meta property=\"og:url\" content=\"http://erichan.postach.io/permalink/6156ed141a\"&gt; &lt;meta property=\"og:description\" content=\"This is a test.\"&gt; &lt;!-- Twitter Cards --&gt; &lt;meta name=\"twitter:card\" content=\"summary\"&gt; &lt;meta name=\"twitter:site\" content=\"@https://twitter.com/future_go\"&gt; &lt;meta name=\"twitter:title\" content=\"Test\"&gt; &lt;meta name=\"twitter:description\" content=\"This is a test....\"&gt; &lt;meta name=\"twitter:creator\" content=\"@https://twitter.com/future_go\"&gt; &lt;meta name=\"twitter:domain\" content=\"http://erichan.postach.io\"&gt; &lt;link rel=\"canonical\" href=\"http://erichan.postach.io/permalink/6156ed141a\"&gt; &lt;!-- RSS feed --&gt; &lt;link rel=\"alternate\" type=\"application/rss+xml\" title=\"RSS\" href=\"http://erichan.postach.io/feed.xml\"&gt;&lt;/head&gt; 테스트로 만든 포스트의 &lt;head&gt; 태그 일부입니다. 오픈그래프 (Open Graph) 와 각종 메타 태그가 잘 정리되어있습니다. RSS feed 까지 잘 만들어져 있습니다. 깔끔하네요! 트위터 아이디도 연동시켜놨더니 알아서 트위터 관련 태그도 추가되어 있군요. 단점가장 큰 단점은 여러가지 기능을 유료로 제공한다는 점입니다. 물론 좋은 기능을 사용할 때 합당한 비용을 지불하는 것은 단점이라고 할 수 없습니다. 저 또한 맥북과 아이폰을 사용하면서 많은 유료앱을 사용하고 있습니다. 하지만 누군가에게는 그만한 비용을 지불하면서까지 그 기능을 사용할 의사 혹은 필요가 없다면 단점이 될 수 있습니다. 추가 사이트 개설은 유료무료 계정은 단 하나의 사이트만 개설이 가능합니다. 블로그 하나 개설하려는 목적이라면 크게 상관이 없을 수도 있겠네요. 커스텀 테마는 유료 (기본 월 5$, 연간 50$)테마를 바꾸거나 테마를 만들고 뜯어고치려면 돈을 내야 합니다. 기본 테마가 딱 하나인데 썩 마음에 들지 않아서 바꾸고 싶은데 말이죠. 기본 테마를 2~3개 줘도 좋았을 것 같네요. 테마 미리보기도 안되는 점은 너무하다는 생각이 듭니다 ㅋㅋ 유료 서비스는 구독 서비스 형식으로, 기본 한달에 5$ 이고 기간을 많이 할수록 가격은 내려갑니다. Evernote Web Clipper에버노트 웹 클리퍼로 클립한 노트는 법적인 이슈와 스타일링 이슈로 게시되지 않는다고 합니다. 체크리스트 사용 불가에버노트에 있는 체크리스트는 내부 이슈로 아직 적용이 안된다고 합니다. 테스트해보니 그냥 텍스트로만 나옵니다. 부가적인 툴같이 사용하면 좋을 것 같은 툴이 있어 소개해드리려고 합니다. Marxico (할인가 연간 15.99$) Marxico 는 에버노트를 위한 온라인 마크다운 에디터입니다. 웹 사이트에서 접속할 수도 있고 크롬 웹스토어에서 설치도 가능합니다. 깔끔하고 성능도 괜찮습니다. 지원하는 마크다운 문법도 많습니다. 프리뷰 화면이 옆에 나와서 바로 확인 가능합니다. 작성한 마크다운 문서는 바로 에버노트와 동기화됩니다. 처음에 보고 정말 마음에 들었는데 한가지 아쉬운 점이 있었습니다. 에버노트로는 Marxico 에서 작성한 노트를 수정할 수가 없는 점입니다. 외부 앱에서 작성한 노트라서 수정이 불가능하다고 나옵니다. 블로그 작성은 Marxico 만 쓰겠다 하면 크게 문제가 안될 수도 있겠네요. 설치해놓고 오랜만에 봤더니 트라이얼 기간이었네요. 역시 좋은 건 돈을 내야 합니다. 연간 $15.99 로 월 1500원 정도네요. 트라이얼 기간이 끝나서 Marxico 로 작성한 문서가 Postach.io 에서 제대로 나오는지는 확인 못해봤습니다. 조만간 확인해보고 수정하겠습니다. ByWord (Mac 13.19$, iOS 6.59$) ByWord 는 수려하고 깔끔한 마크다운 에디터입니다. 저도 현재 사용하고 있는 툴인데 만족스럽게 사용하고 있습니다. ByWord 의 기능 중에 Evernote 로 Export 하는 기능이 있습니다. ByWord 에서 작성하면 에버노트에 올라가면서 Postach 블로그에 게시할 수 있죠. 하지만 이 기능은 추가로 결제해야 하는 기능입니다. iCloud 에 저장이 가능하기 때문에 굳이 에버노트에 저장할 필요가 없었는데 Postach.io 를 사용한다면 필요한 기능일 수 있겠네요. 개인적인 총평2013년 4월에 출시되어 3년이 지났는데 아직 부족한 느낌이 좀 들기도 하네요. 일단 무료 계정으로 사용할 수 있는 활용 범위가 좀 늘어서 사람들이 더 많이 사용하면 유료 사용자도 늘지 않을까 싶습니다. 에버노트도 무료로 충분히 사용할 수 있으나 애정과 필요에 의해서 유료 서비스를 사용하듯이 말이죠. 무료 플랫폼이 많아서 다른 선택지들이 많은 상황이니까요. 그럼에도 불구하고 에버노트라는 점은 매력적입니다. 전체적으로 깔끔하고 쉬운 사용법은 너무나 마음에 듭니다. 만약 사용한다면 마크다운이 꼭 필요하니까 Marxico 랑 함께 사용하고 싶네요.","categories":[{"name":"Reviews","slug":"Reviews","permalink":"http://futurecreator.github.io/categories/Reviews/"}],"tags":[{"name":"markdown","slug":"markdown","permalink":"http://futurecreator.github.io/tags/markdown/"},{"name":"blog","slug":"blog","permalink":"http://futurecreator.github.io/tags/blog/"},{"name":"evernote","slug":"evernote","permalink":"http://futurecreator.github.io/tags/evernote/"},{"name":"postach","slug":"postach","permalink":"http://futurecreator.github.io/tags/postach/"}]},{"title":"스프링 부트 (Spring Boot) 로 시작하는 프레임워크 (Framework)","slug":"spring-boot-get-started","date":"2016-06-18T01:35:37.000Z","updated":"2016-06-21T07:10:14.000Z","comments":true,"path":"2016/06/18/spring-boot-get-started/","link":"","permalink":"http://futurecreator.github.io/2016/06/18/spring-boot-get-started/","excerpt":"","text":"스프링을 사용하다보니 좋은 프레임워크긴 하지만 지옥같은 XML 설정과 방대한 양의 코드 때문에 애를 먹었습니다. 간단한 소규모 혹은 개인 프로젝트에서도 스프링을 사용하고 싶은데 왠지 무거운 느낌입니다. 그러던 중 예전에 들었던 스프링부트가 생각나서 프로토타입을 만들 때 적용해보기로 했습니다. 많은 설정을 자동화시켜서 훨씬 쉽고 간단하게 사용할 수 있다고 합니다. 그렇다면 스프링 프레임워크를 시작하기 전에, 먼저 프레임워크가 무엇인지부터 알아보겠습니다. 프레임워크 (Framework)디자인 패턴 (Design Pattern)절차형 언어에서 객체지향 언어로 넘어오면서 설계의 중요성이 커졌습니다. 객체지향은 객체들이 서로 메시지를 주고 받고 서로를 사용하면서 작업을 수행하기 때문에 객체를 어떻게 설정하고 객체 간 관계를 어떻게 정할 것인지, 이런 설계 작업이 핵심적으로 중요해졌습니다. 객체지향을 처음 배우는 사람들에게 이런 설계 개념을 설명하기 위해서 기존 개발 건 중에 설계가 잘 된 케이스들을 뽑아서 가르치기 시작했습니다. 이런 케이스들을 이름을 붙이고 목적과 용도, 그리고 구현 방법을 잘 정리해놓은 것이 바로 디자인 패턴 입니다. 그래서 아무렇게나 설계하는 것이 아니라 필요한 디자인 패턴을 참고해서 설계하면 효율적으로 설계할 수가 있게 되었죠. 라이브러리 (Library)라이브러리는 어떠한 기능을 다른 사람들도 사용할 수 있도록 만들어 놓은 것을 말합니다. 예를 들어, 내가 만드는 애플리케이션 안에 이미지 변환 기능이 필요하다고 합시다. 그러면 이미지 변환 기능이 필요한 사람들은 모두 기능을 각자 구현해야곘죠. 하지만 그렇게 하지 않고 이미지 변환 기능을 다른 사람들도 소스 안에서 사용할 수 있도록 jar 형태로 묶어서 제공하는 것이 바로 라이브러리입니다. 프레임워크 = 디자인 패턴 + 라이브러리프레임워크란 이름에서부터 알 수 있듯이 애플리케이션을 개발할 때 사용하는 일종의 틀을 말합니다. 앞서 말한 디자인패턴과 라이브러리들을 모아서 프로그램 형태로 만들어놓은 겁니다. 그래서 프레임워크를 사용하면 여러가지 유용한 기능을 통해 개발자는 구현해야 하는 핵심 로직에 집중할 수가 있습니다. 예를 들어, 나는 해변에 앉아 있는 사람을 그리고 싶다면, 이미 해변 그려져 있는 해변 그림을 가져다가 내가 그리고 싶은 앉아 있는 사람만 그리는 거라고나 할까요. 이를 통해서 사용자는 개발 생산성 향상과 일정 수준 이상의 품질을 보장받을 수 있습니다. 개발자의 실력에 상관없이 고급 기능들을 적용할 수 있기 때문에 대규모 프로젝트에서는 프레임워크를 반드시 사용합니다. 스프링 프레임워크 (Spring Framework)스프링 프레임워크 는 자바 기반의 애플리케이션 프레임워크입니다. 웹 애플리케이션 서버 사이드 개발 시 많이 사용되고, 웹 뿐만 아니라 많은 곳에서 사용된다고 합니다. 스프링 홈페이지에 가보면 상당히 많은 프로젝트 가 있습니다. 우리나라 공공기관 웹 서비스 개발할 때 사용하는 전자정부 프레임워크도 스프링 기반으로 되어있습니다. 스프링 핵심 기능스프링의 핵심 기능은 다음과 같습니다. 각각에 대해서 설명하기에는 양이 너무 방대하니 자세한 내용은 다른 포스팅을 통해서 하나씩 알아보기로 하죠. 의존 주입 (Dependency Injection) 관점 지향 프로그래밍 (AOP; Aspect-Oriented Programming) 스프링 MVC 웹 애플리케이션과 RESTful 웹 서비스 프레임워크 (Spring MVC web application and RESTful web service framework) JDBC, JPA, JMS 지원 스프링 모듈 스프링은 여러가지 모듈로 이뤄져 있어서 내가 필요한 모듈만 뽑아서 사용할 수가 있습니다. 정말 유용한 기능이 많지만 방대하고 내용이 많아서 공부해야할 난이도도 올라갑니다. 스프링 부트 (Spring Boot) 스프링 부트는 스프링의 여러가지 프로젝트 중 하나입니다. 스프링을 사용해보신 분들은 아시겠지만 설정할 내용도 굉장히 많고, XML 파일로 설정할 경우 정말 눈이 빠질만큼 힘듭니다. XML 은 컴파일도 안되니 오타 하나만 나도 찾기가 정말 어렵죠. 이런 단점들을 보완해서 간단히 실행할 수 있는 것이 스프링 부트입니다. 시작해보시면 알겠지만 설정할 것도 거의 없고 그냥 실행 만 시키면 내장 서버에 배포되어 바로 뜹니다. 기존에 설정하던 것들을 자동화시켜서 많이 걷어냈습니다. 그래서 프로토타입을 만들 때 스프링 부트를 활용해보기로 결정했습니다. 기능 내장 서버: WAR 파일을 배포할 필요 없이 내장된 Tomcat, Jetty, Unertow 를 이용해 실행할 수 있습니다. 간단한 라이브러리 관리: 많이 사용하는 라이브러리를 모아놓은 스타터 (Starter) POM 파일로 메이븐 설정이 쉬워집니다. 자동 설정: 더 이상 XML 설정이 필요하지 않습니다. 레퍼런스 가이드 (Reference Guide): 문서화가 잘 되어 있어서 개발할 때 찾아보기 편합니다. 스프링 부트 시작하기Spring Tool Suite스프링 부트를 시작하기 위해 Spring Tool Suite (이하 STS) 를 설치합니다. STS는 이클립스 (Eclipase) 기반의 스프링 개발 환경입니다. 설치는 STS 홈페이지에서 압축 파일을 다운로드 받아 원하는 곳에 압축을 해제하면 됩니다. 혹은 기존에 사용하는 이클립스에서 스프링 플러그인을 설치해서 사용할 수도 있습니다. Hello, Spring Boot!역시 새로 배울 때는 ‘Hello, world’ 죠. 사용자의 이름을 받아서 Hello, World랑 같이 화면에 뿌려보겠습니다. 프로젝트 생성new &gt; Spring Starter Project 로 프로젝트를 생성합니다. 프로젝트 이름을 입력하고 메이븐 (Maven) 을 이용해서 진행하겠습니다. 프로젝트를 생성할 때 미리 POM 파일을 구성할 수 있습니다. 어지간한 건 거의 다 있어서 클릭만하면 되니까 편하군요. 물론 이후에도 POM 파일을 수정 가능합니다. 아래 세 가지 모듈을 선택하고 완료를 누르면 필요한 라이브러리들을 모두 다운받습니다. Web : 웹 개발 관련 라이브러리 모음 Velocity : 템플릿 엔진 중 하나인 Velocity DevTools : 개발 툴로 서버 자동 재시작 등을 지원 프로젝트 생성 완료 후 패키지 구조입니다. 123456789101112HelloSpring [boot][devtools]├── src/main/java ├── com.han ├── HelloSpringApplication.java ├── ServletInitializer.java├── src/main/resources ├── static ├── templates application.properties├── src/test/java├── targetpom.xml 인덱스 (Index) 페이지 만들기src/main/resources/static 경로에 index.html 을 추가합니다. index.html 은 기본 URL 로 접속 시 접속되는 화면입니다. static 폴더는 사이트의 정적인 파일들을 관리할 때 사용합니다. 정적 HTML 문서, 이미지, 영상 등이 있습니다. index.html12345678910&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;Index&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;INDEX&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; 컨트롤러 (Controller) 만들기com.han.web 패키지를 만들어서 HelloController.java 를 생성합니다. HelloController.java12345678@Controllerpublic class HelloController &#123; @RequestMapping(\"/hello\") public @ResponseBody String hello() &#123; return \"Hello, Spring Boot!\"; &#125;&#125; 컨트롤러는 Dispatcher Servlet 에서 받은 요청에 따라 로직을 처리하는 역할을 합니다. 여기서는 /hello라는 경로로 오는 요청에 “Hello, Spring Boot!”라는 응답을 보냅니다. @ResponseBody 어노테이션을 이용해 String 자체를 응답의 body로 사용해서 보냅니다. 실행하기이제 실행을 해봅니다. 따로 서버 구성할 필요 없이 HelloSpringApplication.java 파일을 오른쪽 클릭해서 Run as.. &gt; Spring Boot App 으로 실행합니다. HelloSPringApplication.java1234567@SpringBootApplicationpublic class HelloSpringApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(HelloSpringApplication.class, args); &#125;&#125; 웹 애플리케이션인데 메인 함수가 있군요. 내장된 톰캣 대신 설정을 통해 Jetty나 Undertow를 사용할 수도 있고, 외부 서버를 사용할 수도 있습니다. 기본 포트는 8080 입니다. 포트 충돌 에러가 나시는 분들은 src/main/resources/application.properties 에서 다음과 같이 작성하고 8080 대신 다른 포트로 수정합시다. 1server.port = 8080; 잘 떴다면 이런 로그가 뜹니다. 12Tomcat started on port(s): 8080 (http)Started HelloSpringApplication in 2.047 seconds (JVM running for 2.794) http://localhost:8080/로 접속해보면 index.html 화면을 볼 수 있고, http://localhost:8099/hello로 접속하면 ‘Hello, Spring Boot!’ 를 확인할 수 있습니다. Hello, Eric!이번에는 이름을 같이 출력하도록 변경해보겠습니다. 다음과 같은 순서로 동작하게 됩니다. 클라이언트에서 /hello 경로로 서버에 name 을 전달합니다. (GET 방식) 서버는 문자열을 조립해서 greetings 라는 스트링을 만들고 클라이언트에 응답합니다. 서버에서 오는 데이터를 클라이언트에서 렌더링하기 위한 템플릿 엔진으로는 Velocity 를 사용하겠습니다. Velocity 파일에서는 서버에서 받은 greetings 라는 스트링을 출력합니다. Velocity 파일 생성하기HTML 파일을 생성하고 다음과 같이 작성한 후에 .vm 확장자로 변경합니다. hello.vm123456789101112&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;Hello&lt;/title&gt;&lt;/head&gt;&lt;body&gt;$greetings&lt;/body&gt;&lt;/html&gt; $greetings 이라는 부분은 서버에서 greetings 라는 이름으로 오는 데이터를 맵핑해주는 부분입니다. 컨트롤러 수정하기이제 컨트롤러를 해당 파라미터를 처리할 수 있도록 변경합니다. HelloController.java1234567891011121314@Controllerpublic class HelloController &#123; @RequestMapping(\"/hello\") public String hello(Model model, @RequestParam(value = \"name\", defaultValue = \"Unknown\", required = false) String name) &#123; String greetings = \"Hello, \" + name + \"!\"; model.addAttribute(\"greetings\", greetings); return \"hello\"; &#125;&#125; @RequestParam 어노테이션을 이용해 클라이언트에서 넘어온 name 이라는 파라미터를 받습니다. @RequestParam 은 HttpRequest 로 넘어오는 파라미터와 선언한 변수를 맵핑해주는 역할을 합니다. 만약 name 을 전달하지 않는다면 에러가 납니다. 1@RuquestParam(value=\"name\", required=false) String name 이런 식으로 필수여부를 false 로 지정하지 않는다면 말이죠. 이럴 때는 빈 값으로 표시됩니다. 우리는 name 이 넘어오지 않는 경우에는 기본값으로 ‘Unknown’ 이라는 문자열이 나오도록 했습니다. 실행하기아까 띄워놓은 서버는 변경이 있을 때 자동 재시작이 되므로 변경사항은 바로 적용됩니다. 이제 접속을 해봅시다. 1http://localhost:8080/hello name 이 없기 때문에 기본값으로 설정해놓은 Unknown 을 사용해 출력됩니다. 클라이언트에서 GET 방식으로 서버에 요청할 떄는 URL 뒤에 파라미터를 이어 붙여서 요청합니다. name 이라는 이름의 파라미터를 줘보겠습니다. 1http://localhost:8080/hello?name=Eric URL 뒤에 물음표 (?) 를 붙이고 파라미터를 적습니다. 그러면 Eric 이라는 문자열이 name 이라는 이름을 가지고 서버로 보내집니다. 스프링부트를 이용해 아주 간단한 애플리케이션을 만들어봤습니다. 다음 포스트에서는 DB 를 설치하고 JPA 를 이용해서 스프링부트와 연결해보겠습니다. Related Posts스프링 부트 (Spring Boot) 로 시작하는 프레임워크 (Framework)","categories":[{"name":"Spring","slug":"Spring","permalink":"http://futurecreator.github.io/categories/Spring/"}],"tags":[{"name":"spring","slug":"spring","permalink":"http://futurecreator.github.io/tags/spring/"},{"name":"springboot","slug":"springboot","permalink":"http://futurecreator.github.io/tags/springboot/"},{"name":"velocity","slug":"velocity","permalink":"http://futurecreator.github.io/tags/velocity/"}]},{"title":"구글(Google) 검색 원리와 검색이 잘 되게 하는 방법","slug":"google-search-how-to-work","date":"2016-06-16T15:05:28.000Z","updated":"2016-06-28T13:48:49.000Z","comments":true,"path":"2016/06/17/google-search-how-to-work/","link":"","permalink":"http://futurecreator.github.io/2016/06/17/google-search-how-to-work/","excerpt":"","text":"지난 포스트에서 구글 검색이 잘 되게 하기 위한 몇가지 방법을 알아봤습니다. 사이트맵과 RSS feed 도 제출하고, 메타 태그도 수정했었죠. 그게 구글 검색 결과에 어떤 영향을 미칠까요? 이 수 많은 웹의 자료들 중에서 과연 구글은 대체 어떻게 검색을 할까요? 우리가 아주 두꺼운 전공책에서 어떤 키워드에 해당하는 페이지를 찾는다고 해보죠. 처음에는 목차를 볼 수 있겠지만 해당 내용을 어느정도 알고 있지 않는 한 해당 키워드가 어디에 나올지 예측하기가 어렵습니다. 그럴 때 사용하는 것이 바로 찾아보기 입니다. 찾아보기 페이지를 보면, 책에서 중요하다고 생각하는 키워드들을 모아서 가나다 순 혹은 중요도 순으로 정렬을 해놓고, 해당 내용이 몇 페이지에 있는지 쭉 나열되어 있죠. 이런걸 색인 이라고 합니다. 구글도 바로 색인을 통해서 키워드를 검색합니다. 다음 세 가지 키워드를 통해서 자세하게 살펴보겠습니다. 크롤링: 일단 구글이 정보를 수집하고, 색인: 정보를 가지고 색인 (찾아보기)를 만들고, 검색 결과 선택: 그 중에서 가장 유용한 페이지를 선택. 크롤링크롤링은 이전 포스트에서도 계속 나와서 익숙하실 겁니다. 웹 상에 새롭게 생성된 페이지나 업데이트된 페이지를 찾아서 가져오는 작업을 말합니다. 사용자가 원하는 결과를 찾아주기 위해서 일단 많은 웹 페이지를 방문해서 정보를 수집하는 거죠. 이런 작업을 수행하는 프로그램을 크롤러라고 하고 구글에서는 Googlebot 이라고 합니다. 지난 포스트에서 검색이 잘 되게 하기 위해서 Search Console 이라는 구글 웹 마스터 도구를 이용해서 사이트맵을 제출하고, RSS feed 를 제출하는 과정을 함께 했습니다. 이러한 작업은 내 사이트의 웹 페이지 정보를 제출하는 것인데요, Googlebot은 이렇게 우리가 제출한 자료를 가지고 이 사이트에 새로운 자료가 있는지, 업데이트 된 자료가 있는지, 삭제된 자료가 있는지 확인하고 실제로 방문할지 말지를 결정합니다. 또한 방문했을 때는 페이지의 메타 태그를 통해서 해당 페이지의 정보를 파악합니다. 그래서 유효한 메타 태그를 잘 작성해놓아야 크롤러가 내 페이지의 정보를 잘 수집하가게 됩니다. 색인 생성Googlebot 은 크롤링을 통해 수집한 정보를 바탕으로 색인을 작성합니다. 예를 들어 ‘Hexo 에 대한 내용이 필요하면 이 블로그를 보여준다.’ 이런 식으로 말이죠. 하지만 이런 페이지가 한 두개가 아닐겁니다. 그 중에서 어떤 순서로 페이지를 보여줄 것인지 선택을 해야 합니다. 검색 결과 선택이제 실제로 사용자가 검색어를 입력했을 때, 구글 검색엔진은 만들어놓은 색인에서 일치하는 페이지를 검색해서 사용자에게 제일 유용하다고 판단되는 결과를 표시합니다. 이러한 판단은 무엇을 기준으로 할까요? 여기서 사용되는 것이 구글 고유의 검색 기술인 PageRank 입니다. PageRank 는 다른 페이지에서 이 페이지를 인용(링크)하는 횟수를 가지고 이 페이지가 얼마나 유용하고 중요한지 판단하는 기술입니다. 다른 사람들이 많이 링크를 걸고 글을 쓸 때 인용을 한다면 그만큼 그 페이지의 내용이 좋고 중요하다는 뜻이겠죠. 이렇게 유용성을 판단하는데는 PageRank 외에도 200가지 이상의 요인이 있다고 하네요. 구글 자동완성 기능도 이런 중요도를 바탕으로 했기 떄문에 검색어를 예상해서 보여줄 수 있습니다. 검색 결과 사이트 순위를 올리는 방법그렇다면 검색이 잘 되게 하려면 어떻게 해야 할까요? 수많은 웹 페이지 중에서 내 사이트를 검색 결과 상위에 노출시키려면 어떻게 해야 할까요? 힌트는 위에서 모두 나왔습니다. 다시 한번 정리하면서 살펴보겠습니다. Search Console 사용Search Console 을 통해서 사이트를 등록하고, 사이트맵을 제출합니다. 그래야 크롤러가 내 사이트의 정보를 잘 수집할 수 있습니다. 사실 등록을 하는 사람이 많기 때문에 등록을 해도 본전이긴 하겠네요. 또한 Search Console 에서 제공하는 Fetch as Google 기능을 사용합니다. 이걸 사용하면 크롤러가 내 페이지에 방문했을 때 어떻게 보이고 어떤 정보를 가져가는지 확인할 수 있습니다. 크롤러가 차단당해서 가져가지 못하는 자원이 있는지 확인할 수 있으니 그에 맞게 조치를 취할 수 있습니다. 구글과 방문자가 좋아하는 페이지 만들기 정확한 주제에 맞는 키워드를 이용해서 제목과 본문을 작성합니다. 이런 키워드는 사람들이 검색어로 사용할만한 키워드여야 합니다. 페이지 계층 구조가 명확하도록 글을 작성합니다. 반응형 페이지로 제작해 모바일이나 태블릿에서도 잘 보이도록 합니다. 여러 브라우저에서 잘 보이는지 확인합니다. 가능한 경우 암호화된 통신인 HTTPS 를 이용합니다. 웹 페이지의 속도를 측정하고 향상시켜야 합니다. 해당 정보는 구글의 Pagespeed Insight 를 활용하면 좋습니다. 사용법은 다음에 포스팅하겠습니다. 역시 콘텐츠무엇보다도 중요한 것은 내용입니다. 정말 유용한 사이트는 즐겨찾기를 하고 자주 방문하게 됩니다. 너무나 뻔한 이야기죠? 그래도 콘텐츠가 가장 중요합니다. 사이트의 전문 분야에서 다른 경쟁 사이트들과 차별화되도록 해야 합니다. 내용도 내용이고, 디자인이나 사용자 환경도 신경을 많이 써야겠죠. 저도 블로그를 시작한 지 얼마 안됬지만 앞으로 좋은 콘텐츠를 많이 쌓아야겠습니다. 다음 번에는 Pagespeed Insight 사용해서 페이지 속도를 개선하는 방법을 알아보겠습니다. Related Posts 구글(Goolge) 사이트 등록(Search Console)과 검색엔진 최적화(SEO) 네이버 사이트 등록(웹마스터 도구)과 검색엔진 최적화(SEO) Hexo 블로그에 구글 애드센스(Adsense) 추가하기 오픈 그래프 (Open Graph) 태그와 페이스북 도메인 인사이트 (Domain Insight) 구글(Google) 검색 원리와 검색이 잘 되게 하는 방법 검색 엔진 최적화(SEO)에 유용한 Hexo 플러그인 구글 검색 상위 노출을 위한 200가지 팁","categories":[{"name":"Web","slug":"Web","permalink":"http://futurecreator.github.io/categories/Web/"},{"name":"Hexo","slug":"Web/Hexo","permalink":"http://futurecreator.github.io/categories/Web/Hexo/"}],"tags":[{"name":"google","slug":"google","permalink":"http://futurecreator.github.io/tags/google/"},{"name":"search","slug":"search","permalink":"http://futurecreator.github.io/tags/search/"},{"name":"googlebot","slug":"googlebot","permalink":"http://futurecreator.github.io/tags/googlebot/"},{"name":"pagerank","slug":"pagerank","permalink":"http://futurecreator.github.io/tags/pagerank/"}]},{"title":"Hexo 블로그에 구글 애드센스(Adsense) 추가하기","slug":"add-google-adsense-to-hexo","date":"2016-06-16T06:35:16.000Z","updated":"2016-06-28T13:49:11.000Z","comments":true,"path":"2016/06/16/add-google-adsense-to-hexo/","link":"","permalink":"http://futurecreator.github.io/2016/06/16/add-google-adsense-to-hexo/","excerpt":"","text":"블로그가 광고로 지저분해지는 게 마냥 좋은 건 아니지만, 그래도 광고 수입을 포기할 수 없죠. 인터넷 뉴스 사이트처럼 광고로 점칠되어 있는 정도가 아니라면 괜찮을 것 같습니다. 내용에 읽는데 무리가 없되 적당히 눈에 잘 띄는 곳에 설치해보겠습니다. 애드센스 광고 생성하기애드센스 승인이 나셨다면 이제 광고를 달 수 있습니다. 애드센스 홈페이지 에서 광고를 새로 만들고, 그 광고를 내 블로그에 붙이면 됩니다. 먼저, 애드센스 홈페이지에서 내 광고 &gt; 콘텐츠 &gt; 광고 단위 메뉴에 들어가서 새 광고를 만듭니다. 크기와 색상을 선택할 수 있는데 크기는 반응형 으로 선택합니다. 화면 크기와 위치에 따라 자동으로 크기가 변하기 때문에 같은 코드로 어느 위치에 넣어도 되니까 크게 신경 안써도 되고 편합니다. 등록을 완료하면 고유의 코드가 생성됩니다. 이제 이걸 본인의 사이트에 넣으면 됩니다. 12345678910&lt;script async src=\"//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js\"&gt;&lt;/script&gt;&lt;!-- 광고 --&gt;&lt;ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-1111111111111111\" data-ad-slot=\"1111111111\" data-ad-format=\"auto\"&gt;&lt;/ins&gt;&lt;script&gt;(adsbygoogle = window.adsbygoogle || []).push(&#123;&#125;);&lt;/script&gt; Hexo 의 레이아웃적용한 테마마다 형식이 조금씩 다르겠지만 보통 테마 폴더 안에 있는 layout 폴더에 ejs 파일들이 있습니다. EJS 는 Embedded JavaScript 로 HTML 내에 자바스크립트를 넣는 클라이언트-사이드 템플릿 언어입니다. HTML 내에 Java 소스를 넣는 JSP 처럼 말이죠. 전체적인 레이아웃은 layout.ejs 를 보시면 됩니다. 제 사이트의 layout.ejs 를 예로 살펴보겠습니다. layout.ejs12345678910111213141516171819202122&lt;%- partial('common/head') %&gt;&lt;body&gt; &lt;div id=\"wrap\"&gt; &lt;%- partial('common/header', null, &#123;cache: !config.relative_link&#125;) %&gt; &lt;div class=\"container\"&gt; &lt;div class=\"main-body container-inner\"&gt; &lt;div class=\"main-body-inner\"&gt; &lt;section id=\"main\"&gt; &lt;%- partial('common/content-title') %&gt; &lt;div class=\"main-body-content\"&gt; &lt;%- body %&gt; &lt;/div&gt; &lt;/section&gt; &lt;%- partial('common/sidebar') %&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;%- partial('common/footer', null, &#123;cache: !config.relative_link&#125;) %&gt; &lt;%- partial('common/scripts') %&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 전체적인 레이아웃을 결정하고 있는데 부분적인 소스는 ejs 파일로 따로 빼놓고 &lt;%- partial() %&gt; 을 이용해서 조립하고 있습니다. header, footer, sidebar 등 해당 경로에 ejs 파일로 따로 존재합니다. 이러한 표현식은 Hexo 에서 제공하는 Helper라는 표현식으로 코드를 쉽게 입력할 수 있도록 도와줍니다. 나중에 따로 다루겠습니다. Hexo 에 애드센스 코드 추가하기이제 생성한 코드를 넣을 차례입니다. 저는 본문 앞과 뒤, 그래고 사이드에 추가했습니다. 본문 내용을 해치지 않으면서 처음과 끝이라 눈에도 잘 띄고 사이드바에 넣으면 스크롤을 내리는 중간에도 광고가 노출되기 때문입니다. 애드센스 코드 저장일단 여러군데 같은 소스로 활용하기 위해 반응형 광고를 만들었었죠. 복사한 코드를 테마 폴더 안 layout/ads 라는 폴더를 만들고 adsense.ejs 라는 파일로 저장합시다. (물론 아래 코드는 예시입니다.) adsense.ejs12345678910&lt;script async src=\"//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js\"&gt;&lt;/script&gt;&lt;!-- 광고 --&gt;&lt;ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-1111111111111111\" data-ad-slot=\"1111111111\" data-ad-format=\"auto\"&gt;&lt;/ins&gt;&lt;script&gt;(adsbygoogle = window.adsbygoogle || []).push(&#123;&#125;);&lt;/script&gt; 1. &lt;body&gt; 태그 위&lt;%- body %&gt; 는 본문 내용의 템플릿입니다. 아까 살펴봤던 layout.ejs 에서 &lt;%- body %&gt; 앞에다가 &lt;%- partial(&#39;ads/adsense&#39;) %&gt; 를 넣으면 본문 상단에 광고가 표시됩니다. 이때 확장자 ejs 는 쓰면 안됩니다. layout.ejs1234567891011121314151617181920212223&lt;%- partial('common/head') %&gt;&lt;body&gt; &lt;div id=\"wrap\"&gt; &lt;%- partial('common/header', null, &#123;cache: !config.relative_link&#125;) %&gt; &lt;div class=\"container\"&gt; &lt;div class=\"main-body container-inner\"&gt; &lt;div class=\"main-body-inner\"&gt; &lt;section id=\"main\"&gt; &lt;%- partial('common/content-title') %&gt; &lt;div class=\"main-body-content\"&gt; &lt;%- partial('ads/adsense') %&gt; &lt;%- body %&gt; &lt;/div&gt; &lt;/section&gt; &lt;%- partial('common/sidebar') %&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;%- partial('common/footer', null, &#123;cache: !config.relative_link&#125;) %&gt; &lt;%- partial('common/scripts') %&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 2. 본문 하단본문 하단에 넣으려면 그냥 &lt;%- body %&gt; 아래에다 넣으면 될까요? 그러면 밑에 있는 footer 때문에 제대로 표시되질 않습니다. 본문 밑에 있는 댓글과 공유버튼 위쪽에 삽입해야 합니다. layout/common/article.ejs 를 확인해봅시다. article.ejs 는 본문 내용을 표현하고 있습니다. article.ejs1234567891011121314151617181920&lt;article id=\"&lt;%= post.layout %&gt;-&lt;%= post.slug %&gt;\" class=\"article article-single article-type-&lt;%= post.layout %&gt;\" itemscope itemprop=\"blogPost\"&gt; &lt;div class=\"article-inner\"&gt; &lt;% if (post.link || post.title) &#123; %&gt; &lt;header class=\"article-header\"&gt; &lt;%- partial('post/title', &#123; class_name: 'article-title' &#125;) %&gt; &lt;/header&gt; &lt;% &#125; %&gt; &lt;div class=\"article-subtitle\"&gt; &lt;%- partial('post/date', &#123; class_name: 'article-date', date_format: null &#125;) %&gt; &lt;%- partial('post/tag') %&gt; &lt;/div&gt; &lt;div class=\"article-entry\" itemprop=\"articleBody\"&gt; &lt;%- post.content %&gt; &lt;/div&gt; &lt;footer class=\"article-footer\"&gt; &lt;%- partial('share/index', &#123; post: post &#125;) %&gt; &lt;/footer&gt; &lt;/div&gt;&lt;/article&gt;&lt;%- partial('comment/index') %&gt; article-footer 를 보면 공유버튼 부분이 있고 본문 내용이 다 끝난 후에 comment/index.ejs 가 삽입되겠군요. &lt;%- partial(&#39;ads/adsense&#39;) %&gt;를 공유 버튼 위에 넣어줍니다. article.ejs1234567&lt;div class=\"article-entry\" itemprop=\"articleBody\"&gt; &lt;%- post.content %&gt;&lt;/div&gt;&lt;%- partial('ads/adsense') %&gt;&lt;footer class=\"article-footer\"&gt; &lt;%- partial('share/index', &#123; post: post &#125;) %&gt;&lt;/footer&gt; 3. 사이드바본문 상단에 광고가 있으니까 본문 중간 쯤 광고가 나오게 하기 위해서 사이드바 마지막 부분에 광고를 넣어보겠습니다. 사이드바 코드는 layout/common/sidebar.ejs 입니다. sidebar.ejs123456789101112131415161718192021222324252627&lt;aside id=\"sidebar\"&gt; &lt;a class=\"sidebar-toggle\" title=\"Expand Sidebar\"&gt;&lt;i class=\"toggle icon\"&gt;&lt;/i&gt;&lt;/a&gt; &lt;div class=\"sidebar-top\"&gt; &lt;p&gt;&lt;%= __('sidebar.follow') %&gt;:&lt;/p&gt; &lt;ul class=\"social-links\"&gt; &lt;% for (var i in theme.customize.social_links) &#123; %&gt; &lt;% if (theme.customize.social_links[i]) &#123; %&gt; &lt;li&gt; &lt;a class=\"social-tooltip\" title=\"&lt;%= i %&gt;\" href=\"&lt;%- url_for(theme.customize.social_links[i]) %&gt;\" target=\"_blank\"&gt; &lt;i class=\"icon fa fa-&lt;%= i %&gt;\"&gt;&lt;/i&gt; &lt;/a&gt; &lt;/li&gt; &lt;% &#125; %&gt; &lt;% &#125; %&gt; &lt;/ul&gt; &lt;/div&gt; &lt;% if (is_post()) &#123; %&gt; &lt;%- partial('post/nav', &#123;post: page&#125;) %&gt; &lt;% &#125; %&gt; &lt;div class=\"widgets-container\"&gt; &lt;% if (theme.widgets) &#123; %&gt; &lt;% theme.widgets.forEach(function(widget) &#123; %&gt; &lt;%- partial('widget/' + widget) %&gt; &lt;% &#125;) %&gt; &lt;% &#125; %&gt; &lt;/div&gt;&lt;/aside&gt; 사이드바 상단에는 소셜링크와 아이콘들이 나열되고 그 뒤에 위젯들이 나오는군요. 위젯 밑에 넣으면 되겠습니다. &lt;/aside&gt; 위에 넣습니다. sidebar.ejs12345678910 &lt;div class=\"widgets-container\"&gt; &lt;% if (theme.widgets) &#123; %&gt; &lt;% theme.widgets.forEach(function(widget) &#123; %&gt; &lt;%- partial('widget/' + widget) %&gt; &lt;% &#125;) %&gt; &lt;% &#125; %&gt; &lt;/div&gt; &lt;%- partial('ads/adsense') %&gt;&lt;/aside&gt; 확인하기로컬 서버에서는 광고가 잘 표시가 안되더군요. 표시가 되었다가 안되었다가 합니다. repository 에 푸쉬를 하고 확인해봅니다. 12$ hexo g$ hexo d 확인해보면 광고 자리에 빈 칸이 제대로 들어가있으면 성공입니다. 처음 게시하는 광고는 게시한 후에 바로 나타나는 것이 아니라 구글봇이 크롤링하면서 광고를 확인해서 바꿔준다고 하네요. 시간은 30분 ~ 2시간 정도 걸린다고 합니다. 일단 빈 칸이 잘 보인다면 성공이니 잠시 기다려보시고 그래도 안된다면 소스에 문제가 있는 것입니다. 저는 한 40분 정도 지나니까 광고가 제대로 보이더군요. 앞으로 얼마가 들어올진 모르겠지만 그래도 광고를 달고 나니 뿌듯합니다. 추가: 페이지 수준 광고페이지 수준 광고는 모바일 화면에서 포스트 상에 광고가 삽입되는 것이 아니라 사용자가 보는 페이지 단위로 삽입되는 광고입니다. 두 가지 종류가 있습니다. 앵커/오버레이: 화면 하단에 배너가 화면을 움직여도 둥둥 떠나니면서 보이는 방식 모바일 전면광고: 화면 이동 시에 전체 화면에 나타나는 광고 앱스토어나 구글 플레이에서 다운받은 무료 앱을 생각해보시면 될 것 같습니다. 앵커는 화면 하단에 둥둥 떠다니는 배너를 말하고, 모바일 전면광고는 앱 사용 도중에 전체 화면으로 광고가 떠서 x를 눌러 닫는 광고를 말합니다. 둘 다 모바일 상에서만 동작합니다. 페이지 수준 광고는 ‘광고 단위’ 메뉴가 아닌 내 광고 &gt; 콘텐츠 &gt; 페이지 수준 광고 (베타) 메뉴에 있습니다. 여기서 적용하려는 광고 형식을 선택해서 활성화한 후에 하단에 ‘코드 가져오기’ 를 눌러서 코드를 복사합니다. ads/adsense_page 폴더에 adsense_page.ejs 라는 파일을 만들어 붙여넣습니다. adsense_page.ejs1234567&lt;script async src=\"//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js\"&gt;&lt;/script&gt; &lt;script&gt; (adsbygoogle = window.adsbygoogle || []).push(&#123; google_ad_client: \"ca-pub-1111111111111111\", enable_page_level_ads: true &#125;); &lt;/script&gt; 이 코드는 &lt;head&gt; 안에 넣으라고 되어있네요. 헤더는 layout/common/head.ejs 안에 있습니다. 맨 마지막 부분에 추가하겠습니다. head.ejs12345678&lt;head&gt; &lt;!-- 중략 --&gt; &lt;%- css('css/style') %&gt; &lt;%- js('vendor/jquery/2.0.3/jquery.min') %&gt; &lt;%- partial('plugin/scripts', &#123; isHead: true &#125;) %&gt; &lt;%- partial('ads/adsense_page') %&gt;&lt;/head&gt; 잘 뜨는지 테스트를 해보겠습니다. 크롬 브라우저를 기준으로, 페이지를 개발자 도구를 이용해서 엽니다. 그 후에 ‘Toogle Device Toolbar’ 라는 메뉴로 화면을 모바일 형식으로 변환합니다. 그리고 나서 테스트하려는 url 맨 뒤에 #googleads 라는 해시태그를 붙이고 refresh 하면 상단에 페이지 수준 관고 테스트가 표시됩니다. 앵커와 모바일 전면광고 두 가지 옵션이 중 선택해서 화면에 어떻게 보이는지 테스트할 수 있습니다. 페이지 수준 광고는 어떻게 보면 사용자 입장에서 좀 짜증날 수도 있습니다. 사용자 환경을 저해하는 요인이 될 수 있죠. 그래도 사용자 환경을 저해하지 않는 한에서 광고가 표시된다고 하니 광고를 추가하기로 했습니다. 다음번 포스트에서는 Hexo 의 템플릿과 Helper 에 대해서 알아보겠습니다. Related Posts 구글(Goolge) 사이트 등록(Search Console)과 검색엔진 최적화(SEO) 네이버 사이트 등록(웹마스터 도구)과 검색엔진 최적화(SEO) Hexo 블로그에 구글 애드센스(Adsense) 추가하기 오픈 그래프 (Open Graph) 태그와 페이스북 도메인 인사이트 (Domain Insight) 구글(Google) 검색 원리와 검색이 잘 되게 하는 방법 검색 엔진 최적화(SEO)에 유용한 Hexo 플러그인 구글 검색 상위 노출을 위한 200가지 팁","categories":[{"name":"Web","slug":"Web","permalink":"http://futurecreator.github.io/categories/Web/"},{"name":"Hexo","slug":"Web/Hexo","permalink":"http://futurecreator.github.io/categories/Web/Hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://futurecreator.github.io/tags/hexo/"},{"name":"google","slug":"google","permalink":"http://futurecreator.github.io/tags/google/"},{"name":"adsense","slug":"adsense","permalink":"http://futurecreator.github.io/tags/adsense/"}]},{"title":"오픈 그래프 (Open Graph) 태그와 페이스북 도메인 인사이트 (Domain Insight)","slug":"opengraph-social-meta-tag","date":"2016-06-16T00:48:32.000Z","updated":"2016-06-28T13:48:44.000Z","comments":true,"path":"2016/06/16/opengraph-social-meta-tag/","link":"","permalink":"http://futurecreator.github.io/2016/06/16/opengraph-social-meta-tag/","excerpt":"","text":"오픈 그래프 (Open Graph) 태그이번 포스팅에서는 오픈 그래프 태그에 대해 알아보겠습니다. 우리가 보통 페이스북이나 카카오톡에서 웹 사이트 URL을 공유할 때를 생각해봅시다. 그러면 해당 URL의 제목, 이미지, 내용 등이 미리보기 형식으로 잘 보이는 페이지가 있는 반면, 어떤 사이트는 이미지가 없거나 이상한 이미지가 잡히고 내용도 제대로 보이지 않는 미리보기가 표시됩니다. 두 차이는 바로 오픈 그래프 태그에 있습니다. 한 마디로 표현하자면 웹 사이트의 URL 링크 공유 시 미리보기를 만들 때 사용하는 태그입니다. 페이스북에서 정의한 메타 태그라고 합니다. 현재는 페이스북 뿐만 아니라 트위터, 카카오톡 등 다양한 곳에서 사용되고 있습니다. 잘 만든 블로그를 공유할 때 미리보기가 이상하다면 클릭하지 않을 확률이 높겠죠? 최적화된 품질로 표시될 수 있도록 메타 태그를 손봐야합니다. 확인하기먼저 현재 페이지는 어떻게 되어있는지 살펴보겠습니다. 브라우저의 개발자 도구크롬 브라우저에서 마우스 오른쪽 클릭해서 검사를 눌러서 맨 위쪽의 &lt;head&gt; 태그를 살펴봅시다. 다음은 제 포스트 소스 중 일부입니다. 이름, 태그, 키워드, 설명 등 해당 페이지에 대한 내용들이 담겨 있습니다. 웹 페이지를 수집하는 검색 엔진 크롤러가 이런 메타태그를 참조해서 페이지를 분석하게 됩니다. 이런 메타 태그 중에 property 가 og인 태그들이 있습니다. 또 twitter나 facebook 으로 되어있는 것들도 있네요. 바로 우리가 찾던 오픈 그래프 태그입니다. 12345678910111213141516171819202122&lt;head&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1, maximum-scale=1\"&gt; &lt;meta name=\"keywords\" content=\"web,blog,google,search,analytics\"&gt; &lt;meta name=\"description\" content=\"이번 포스팅에서는 구글에서 우리 Hexo 블로그가 잘 검색되도록 해보겠습니다. 일단 사이트부터 등록을 하고 검색엔진 최적화를 위한 다양한 기술을 살펴보겠습니다.검색 최적화구글이나 네이버는 수많은 웹사이트를 수집해서 검색 시 결과를 보여줍니다. 이렇게 수집하는 작업을 크롤링이라고 합니다. 아무리 열심히 쓰고 내용이 좋다 하더라도 검색이 안되서 조회수가 없\"&gt; &lt;meta property=\"og:type\" content=\"article\"&gt; &lt;meta property=\"og:title\" content=\"구글(Goolge) 사이트 등록(Search Console)과 검색엔진 최적화(SEO)\"&gt; &lt;meta property=\"og:url\" content=\"http://futurecreator.github.io/2016/06/15/hexo-google-site-serach-console-analytics/index.html\"&gt; &lt;meta property=\"og:site_name\" content=\"Writer, IT Blog\"&gt; &lt;meta property=\"og:description\" content=\"이번 포스팅에서는 구글에서 우리 Hexo 블로그가 잘 검색되도록 해보겠습니다. 일단 사이트부터 등록을 하고 검색엔진 최적화를 위한 다양한 기술을 살펴보겠습니다.검색 최적화구글이나 네이버는 수많은 웹사이트를 수집해서 검색 시 결과를 보여줍니다. 이렇게 수집하는 작업을 크롤링이라고 합니다. 아무리 열심히 쓰고 내용이 좋다 하더라도 검색이 안되서 조회수가 없\"&gt; &lt;meta property=\"og:image\" content=\"http://futurecreator.github.io/images/google_search/analytics.png\"&gt; &lt;meta property=\"og:updated_time\" content=\"2016-06-15T10:28:42.000Z\"&gt; &lt;meta name=\"twitter:card\" content=\"summary\"&gt; &lt;meta name=\"twitter:title\" content=\"구글(Goolge) 사이트 등록(Search Console)과 검색엔진 최적화(SEO)\"&gt; &lt;meta name=\"twitter:description\" content=\"이번 포스팅에서는 구글에서 우리 Hexo 블로그가 잘 검색되도록 해보겠습니다. 일단 사이트부터 등록을 하고 검색엔진 최적화를 위한 다양한 기술을 살펴보겠습니다.검색 최적화구글이나 네이버는 수많은 웹사이트를 수집해서 검색 시 결과를 보여줍니다. 이렇게 수집하는 작업을 크롤링이라고 합니다. 아무리 열심히 쓰고 내용이 좋다 하더라도 검색이 안되서 조회수가 없\"&gt; &lt;meta name=\"twitter:image\" content=\"http://futurecreator.github.io/images/google_search/analytics.png\"&gt; &lt;meta name=\"twitter:creator\" content=\"@future_go\"&gt; &lt;meta property=\"fb:admins\" content=\"100001774570174\"&gt; &lt;link rel=\"canonical\" href=\"http://futurecreator.github.io/2016/06/15/hexo-google-site-serach-console-analytics/\"&gt; &lt;link rel=\"icon\" href=\"/images/favicon.png\"&gt; 페이스북 URL 디버거페이스북 크롤러가 우리 페이지를 어떻게 볼 지, 다른 사람들에게 공유할 때 어떻게 보일지 미리보는 사이트가 있습니다. 페이스북 URL 디버거 를 사용하면 개발자 도구로 소스를 열어보는 것보다 오픈 그래프 태그를 쉽게 분석할 수 있습니다. URL을 입력하고 디버깅을 시작하면 해당 페이지의 미리보기도 나오고, 메타 태그만 뽑아서 보여줍니다. 수정해야할 부분이 있다면 경고를 통해 알려주니 참고해서 수정하시면 됩니다. 기본적인 오픈 그래프 태그수정하기 전에 기본적인 오픈 그래프 태그만 간략하게 살펴보겠습니다. Tag Description og:url 페이지의 표준 URL (데스크탑 URL) og:title 콘텐츠 제목 og:description 콘텐츠 설명. 미리보기에서 제목 아래에 표시 og:site_name 웹 사이트의 이름 (주소 아님) og:image 콘텐츠를 공유 시 표시되는 이미지의 URL fb:app_id 페이스북 인사이트를 사용하기 위한 앱 아이디 fb:admins 웹 사이트용 도메인 인사이트를 사용하기 위한 아이디 Hexo 에서 오픈 그래프 태그 추가하기다행히 Hexo 와 Hueman 테마에서 웬만한 오픈 그래프 태그는 자동으로 만들어줍니다. 소스를 까보시면 헤더 쪽에 다음과 같은 함수로 오픈 그래프 태그를 생성하고 있습니다. 1&lt;%- open_graph([options]) %&gt; Option Description Default title 페이지 제목 (og:title) page.title type 페이지 타입 (og:type) blog url 페이지 URL (og:url) url image 페이지 커버 이미지 (og:image) 첫번째 이미지 site_name 사이트 이름 (og:site_name) config.title description 페이지 설명 (og:desription) 내용의 200자 twitter_card 트위터 카드 타입 (twitter:card) summary twitter_id 트위터 아이디 (twitter:creator) twitter_site 트위터 사이트 (twitter:site) google_plus Google+ 프로필 링크 fb_admins Facebook admin ID fb_app_id Facebook App ID Hueman 테마에서는 _config.yml 에서 오픈 그래프 태그 관련 옵션을 줄 수 있습니다. 1234567# Miscellaneousmiscellaneous: open_graph: # see http://ogp.me fb_app_id: fb_admins: twitter_id: google_plus: 트위터, 구글 플러스트위터와 구글 플러스 아이디를 넣으면 관련 태그를 자동으로 생성해서 넣어줍니다. 제 트위터 아이디인 @future_go 를 입력하면 다음과 같은 태그가 생성됩니다. @ 는 제외하고 입력합니다. 123456&lt;meta name=\"twitter:card\" content=\"summary\"&gt; &lt;meta name=\"twitter:title\" content=\"구글(Goolge) 사이트 등록(Search Console)과 검색엔진 최적화(SEO)\"&gt; &lt;meta name=\"twitter:description\" content=\"이번 포스팅에서는 구글에서 우리 Hexo 블로그가 잘 검색되도록 해보겠습니다. 일단 사이트부터 등록을 하고 검색엔진 최적화를 위한 다양한 기술을 살펴보겠습니다.검색 최적화구글이나 네이버는 수많은 웹사이트를 수집해서 검색 시 결과를 보여줍니다. 이렇게 수집하는 작업을 크롤링이라고 합니다. 아무리 열심히 쓰고 내용이 좋다 하더라도 검색이 안되서 조회수가 없\"&gt; &lt;meta name=\"twitter:image\" content=\"http://futurecreator.github.io/images/google_search/analytics.png\"&gt; &lt;meta name=\"twitter:creator\" content=\"@future_go\"&gt; 저는 구글 플러스를 사용하지 않아서 입력하지 않았지만, 구글 플러스도 마찬가지로 아이디를 입력하면 관련된 메타 태그를 생성해줍니다. 페이스북 도메인 인사이트 (Facebook Domain Insight)이제 페이스북 관련 태그를 넣어봅시다. 페이스북 AppId 와 admins 라는 항목이 있는데 이걸 넣지 않아도 공유할 때는 문제가 없습니다. 이건 페이스북 인사이트 라는 서비스를 위한 항목입니다. 구글 애널리틱스 (Google Analytics) 처럼 페이스북 상에서 공유되는 내 웹사이트의 통계를 내주는 서비스입니다. 페이스북 인사이트 에 접속하시면 앱과 페이지, 도메인 세 가지 종류가 있습니다. 우리는 외부 사이트이므로 도메인 인사이트에 도메인 추가 로 우리의 사이트를 등록합니다. 1&lt;meta property=\"fb:admins\" content=\"12345678\" /&gt; 사이트 추가를 누르면 위와 화면 처럼 메타 태그에 입력하라고 fb:admins 고유번호가 표시됩니다. 사이트를 입력하고 고유 번호는 복사해서 _config.yml 에 붙여넣습니다. 1234miscellaneous: open_graph: # see http://ogp.me fb_app_id: # 앱인 경우 fb_admins: 12345678 # 도메인인 경우 대시보드에서 등록한 URL을 누르면 페이스북 인사이트라는 통계 서비스를 사용할 수 있습니다. 저는 페이스북을 거의 하지 않지만, 언젠가 페이스북에서 제 사이트가 돌아다니는 걸 봤으면 좋겠네요 ㅎㅎ 홈페이지의 메인 사진이 없다?그런데 공유를 하려고 보니, 포스트의 경우 해당 포스트의 이미지가 미리보기에 잘 표시가 되는데 홈페이지의 경우 해당하는 이미지가 없어서 미리보기에 아무것도 표시되질 않더군요. 수정하려고 홈페이지에 이미지를 여기저기 넣어봤지만 먹질 않았습니다. 결국 코드를 까볼 수 밖에 없었죠. 메타 태그를 만드는 부분을 찾아봅시다. Hueman 테마에서는 head.ejs 에서 open_graph() 함수를 이용해서 오픈 그래프 태그를 만들고 있었습니다. ‘head.ejs는 저번 포스트에서 대표 URL 메타 태그를 자동으로 추가할 때 잠깐 봤었죠. 오픈 그래프 함수를 보시면 thumbail 이라는 함수를 통해` 태그를 만들고 있습니다. head.ejs1234567&lt;%- open_graph(&#123; image: thumbnail(page), fb_app_id: theme.miscellaneous.open_graph.fb_app_id, fb_admins: theme.miscellaneous.open_graph.fb_admins, twitter_id: theme.miscellaneous.open_graph.twitter_id, google_plus: theme.miscellaneous.open_graph.google_plus, &#125;) %&gt; thumbnail 은 Hueman 테마에서 사용하는 자체적인 함수군요. 여기서 보면 post 변수가 넘어오는데 여기서 thumbnail 이 없으면 이미지 태그를 검색해서 thumbnail 을 만들어줍니다. 이미지도 없으면 빈 스트링을 리턴하는데, 우리의 홈페이지가 이 경우에 해당하겠네요. thumbnail.js123456789101112131415161718192021222324252627282930/*** Thumbnail Helper* @description Get the thumbnail url from a post* @example* &lt;%- thumbnail(post) %&gt;*/hexo.extend.helper.register('thumbnail', function (post) &#123; var url = post.thumbnail || ''; if (!url) &#123; var imgPattern = /\\&lt;img\\s.*?\\s?src\\s*=\\s*['|\"]?([^\\s'\"]+).*?\\&gt;/ig; var result = imgPattern.exec(post.content); if (result &amp;&amp; result.length &gt; 1) &#123; url = result[1]; &#125; if(url.length &gt; 0) &#123; var pattern = /^[\\\\&#123;0,1&#125;\\/&#123;0,1&#125;]([^\\/^\\\\]+)/, pattern_ = /([^\\/^\\\\]+)/; if ((ret = pattern.exec(url)) != null) &#123; if(ret[0].length == url.length) &#123; url = post.path + ret[1]; &#125; &#125; else if ((ret = pattern_.exec(url)) != null) &#123; if(ret[0].length == url.length) &#123; url = post.path + ret[1]; &#125; &#125; &#125; &#125; return url;&#125;); 그래서 thumbnail.ejs 에서 thumbnail url 이 없으면 카메라 모양의 이미지로 표시하게 됩니다. thumbnail.ejs1234567891011&lt;a href=\"&lt;%- url_for(post.link ? post.link : post.path) %&gt;\" class=\"thumbnail\"&gt; &lt;% var thumbnailUrl = thumbnail(post) %&gt; &lt;% if (thumbnailUrl) &#123; %&gt; &lt;span style=\"background-image:url(&lt;%- thumbnailUrl %&gt;)\" alt=\"&lt;%= post.title %&gt;\" class=\"thumbnail-image\"&gt;&lt;/span&gt; &lt;% &#125; else &#123; %&gt; &lt;span class=\"thumbnail-image thumbnail-none\"&gt;&lt;/span&gt; &lt;% &#125; %&gt; &lt;% if (typeof(counter) !== 'undefined' &amp;&amp; counter) &#123; %&gt; &lt;%- partial('comment/counter') %&gt; &lt;% &#125; %&gt;&lt;/a&gt; 이 문제를 해결하기 위한 방법은 여러가지가 있을 수 있겠지만, thumbnail.js 를 변경하기 보다는 그냥 head.ejs를 수정하는게 낫겠네요. 홈페이지인 경우에 thumbnail() 함수를 타지 않고 특정 이미지를 넣도록 수정하겠습니다. head.ejs1234567891011121314151617181920&lt;% if (is_home()) &#123; %&gt; &lt;%- open_graph(&#123; image: '/images/keyboard.JPG', fb_app_id: theme.miscellaneous.open_graph.fb_app_id, fb_admins: theme.miscellaneous.open_graph.fb_admins, twitter_id: theme.miscellaneous.open_graph.twitter_id, google_plus: theme.miscellaneous.open_graph.google_plus, &#125;) %&gt; &lt;% &#125; else &#123; %&gt; &lt;%- open_graph(&#123; image: thumbnail(page), fb_app_id: theme.miscellaneous.open_graph.fb_app_id, fb_admins: theme.miscellaneous.open_graph.fb_admins, twitter_id: theme.miscellaneous.open_graph.twitter_id, google_plus: theme.miscellaneous.open_graph.google_plus, &#125;) %&gt; /images/keyboard.JPG 라고 표시된 경로에 본인이 원하는 URL을 입력하시면 되겠습니다. 그럼 다시 배포를 하고 확인해봅시다. 12$ hexo g$ hexo d 이제 홈페이지도 이미지가 제대로 나옵니다. 오픈 그래프 태그와 Hexo 에 적용하는 법을 알아봤습니다. 다음 포스팅에서는 Hexo 의 고급 설정과 플러그인, 커스터마이징 등을 살펴보겠습니다. Related Posts 구글(Goolge) 사이트 등록(Search Console)과 검색엔진 최적화(SEO) 네이버 사이트 등록(웹마스터 도구)과 검색엔진 최적화(SEO) Hexo 블로그에 구글 애드센스(Adsense) 추가하기 오픈 그래프 (Open Graph) 태그와 페이스북 도메인 인사이트 (Domain Insight) 구글(Google) 검색 원리와 검색이 잘 되게 하는 방법 검색 엔진 최적화(SEO)에 유용한 Hexo 플러그인 구글 검색 상위 노출을 위한 200가지 팁","categories":[{"name":"Web","slug":"Web","permalink":"http://futurecreator.github.io/categories/Web/"},{"name":"Hexo","slug":"Web/Hexo","permalink":"http://futurecreator.github.io/categories/Web/Hexo/"}],"tags":[{"name":"opengraph","slug":"opengraph","permalink":"http://futurecreator.github.io/tags/opengraph/"},{"name":"social","slug":"social","permalink":"http://futurecreator.github.io/tags/social/"},{"name":"metatag","slug":"metatag","permalink":"http://futurecreator.github.io/tags/metatag/"}]},{"title":"네이버 사이트 등록(웹마스터 도구)과 검색엔진 최적화(SEO)","slug":"hexo-naver-search-webmaster","date":"2016-06-15T07:15:36.000Z","updated":"2016-06-28T13:49:15.000Z","comments":true,"path":"2016/06/15/hexo-naver-search-webmaster/","link":"","permalink":"http://futurecreator.github.io/2016/06/15/hexo-naver-search-webmaster/","excerpt":"","text":"지난 포스트 구글에 사이트 등록을 하고 최적화를 해봤는데요, 이번 포스트에서는 네이버에 등록을 해보겠습니다. 지난 포스트에서 잘 따라오셨다면 많은 부분이 되어 있으니 간단하게 진행하실 수 있을 겁니다. 네이버에 사이트 등록하기네이버 웹마스터 도구 에 접속합니다. 네이버로 로그인하시면 사이트, 앱, 채널 중에 선택해서 등록할 수 있습니다. 채널은 네이버 블로그나 카페를 등록할 수 있습니다. 맛집 블로그인 제 네이버 블로그도 여기에 등록을 해놨습니다. 우리는 사이트를 선택해서 진행합니다. 사이트는 최대 10개까지 등록할 수 있군요. 사이트를 입력하면 지난번처럼 본인 소유인지 확인하는 절차가 있습니다. 구글 때는 애널리틱스 아이디로 등록할 수 있었지만 이번에는 HTML 을 업로드하는 방식으로 진행해야곘네요. http://www.naver.com/naveradebe1df5638d61f041e0992dcd3b57e.html 이런 식으로 자동 생성된 파일이 있네요. 눌러서 저장한 후에 사이트(블로그) 루트 폴더에 업로드하면, 네이버에서 그 파일이 있는지 확인해서 본인을 인증하는 절차입니다. Hexo 에서 루트 폴더는 public 폴더입니다. public 폴더에 다운받은 html 파일을 넣고 배포합니다. 12$ hexo g$ hexo d 배포 후에 사이트로 돌아와 확인을 누르면 본인 인증이 완료됩니다. 사이트 목록에서 등록한 사이트를 선택합니다. 그러면 여러가지 메뉴가 있네요. 구글에 비해 간단하긴 하지만 그래도 메뉴가 깔끔합니다. 현황 을 보기 전에 요청 메뉴에서 RSS 와 사이트맵을 제출하겠습니다. RSS 제출하기구글에서 등록해보셨다면 어렵지 않게 진행하실 수 있습니다. RSS feed 는 해당 사이트의 최신 페이지에 대한 정보를 가지고 있습니다. RSS 리더를 생각해보시면 되겠네요. 지난번 포스트에서 RSS를 자동 생성하는 플러그인을 사용했습니다. 간단하게 다시 설명해보죠. 1. 설치블로그 폴더에서 설치합니다. 1$ npm install hexo-generator-feed --save 2. 설정_config.yml 아래에 다음 내용을 추가합니다. 12345feed: type: atom # atom 또는 rss2 중에 하나를 선택합니다. path: feed.xml # 해당 경로에 xml 파일을 생성합니다. limit: false # 포스트 몇개까지 추가할 것인지 설정합니다. 숫자를 입력할 수 있고 0 또는 false 를 입력하면 모든 포스트를 추가합니다. hub: 이제 generate 할 때마다 루트 폴더에 feed.xml 이라고 생성됩니다. 네이버로 돌아와 RSS 경로를 입력하면 됩니다. 사이트맵 제출하기사이트맵도 거의 동일합니다. 지난번 포스트에서 RSS 처럼 사이트맵을 자동 생성하는 플러그인을 통해 미리 만들어놨죠. 간단하게 다시 설명하겠습니다. 1. 설치Hexo 가 설치된 폴더에서 진행합니다. 1$ npm install hexo-generator-seo-friendly-sitemap --save 2. 설정설치 후에 해당 사이트의 _config.yml 을 수정합니다. 123# sitemap auto generatorsitemap: path: sitemap.xml # 사이트맵이 자동 생성될 경로 이제 generate 할 때마다 루트 폴더에 sitemap.xml 파일이 생성됩니다. 네이버에 해당 sitemap.xml 경로를 입력하면 됩니다. RSS feed 와 사이트맵을 추가했으니 이제 네이버 크롤러가 참고하게 됩니다. 검색엔진 최적화현황의 사이트 최적화 메뉴에서 현재 웹 페이지의 최적화 현황을 확인하실 수 있습니다. 항목 설명 사이트 제목 HTML 문서의 &lt;head&gt; 태그 내에 있는 &lt;title&gt; 태그 사이트 설명 HTML 문서의 &lt;head&gt; 태그 내에 있는 description 메타 정보 Open Graph 제목 HTML 문서의 &lt;head&gt; 태그내에 있는 og:title 메타 정보 Open Graph 설명 HTML 문서의 &lt;head&gt; 태그 내에 있는 og:description 메타 정보 robots.txt 검색엔진이 크롤링할 때 제외할 내용을 적는 파일입니다. 사이트 맵 해당 사이트의 내용을 포함하는 파일입니다. RSS 해당 사이트의 최근 내용을 포함하는 파일입니다. 모바일 사용성 반응형 웹 디자인으로 구현된 사이트인지 판별합니다. 여기서 모바일 사용성은 반응형 웹 디자인으로 구현되었는지 확인하는 것으로 브라우저의 크기에 따라 다르게 나타나는 것을 의미합니다. PC, 태블릿, 스마트폰 등 여러 디바이스에서 각 크기에 맞춰 보이게 해줍니다. 다음 태그를 넣으면 동작합니다. 1&lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1, maximum-scale=1\"&gt; 나머지는 거의 Hexo 와 테마에서 지원해줍니다. 그런데 아마 Open Graph 쪽이 안 되어있을 겁니다. 사이트를 카카오톡이나 페이스북 등에서 공유하면 페이지 미리보기 이미지와 제목, 내용 등이 간략히 요약되서 보여지는데 이 때 사용되는 것이 오픈 그래프 태그입니다. 이 부분은 다음 포스트에서 다루도록 하겠습니다. Related Posts 구글(Goolge) 사이트 등록(Search Console)과 검색엔진 최적화(SEO) 네이버 사이트 등록(웹마스터 도구)과 검색엔진 최적화(SEO) Hexo 블로그에 구글 애드센스(Adsense) 추가하기 오픈 그래프 (Open Graph) 태그와 페이스북 도메인 인사이트 (Domain Insight) 구글(Google) 검색 원리와 검색이 잘 되게 하는 방법 검색 엔진 최적화(SEO)에 유용한 Hexo 플러그인 구글 검색 상위 노출을 위한 200가지 팁","categories":[{"name":"Web","slug":"Web","permalink":"http://futurecreator.github.io/categories/Web/"},{"name":"Hexo","slug":"Web/Hexo","permalink":"http://futurecreator.github.io/categories/Web/Hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://futurecreator.github.io/tags/hexo/"},{"name":"search","slug":"search","permalink":"http://futurecreator.github.io/tags/search/"},{"name":"naver","slug":"naver","permalink":"http://futurecreator.github.io/tags/naver/"},{"name":"webmaster","slug":"webmaster","permalink":"http://futurecreator.github.io/tags/webmaster/"},{"name":"seo","slug":"seo","permalink":"http://futurecreator.github.io/tags/seo/"}]},{"title":"구글(Goolge) 사이트 등록(Search Console)과 검색엔진 최적화(SEO)","slug":"hexo-google-site-search-console-analytics","date":"2016-06-15T05:00:36.000Z","updated":"2016-06-28T13:49:36.000Z","comments":true,"path":"2016/06/15/hexo-google-site-search-console-analytics/","link":"","permalink":"http://futurecreator.github.io/2016/06/15/hexo-google-site-search-console-analytics/","excerpt":"","text":"이번 포스팅에서는 구글에서 우리 Hexo 블로그가 잘 검색되도록 해보겠습니다. 일단 사이트부터 등록을 하고 검색엔진 최적화를 위한 다양한 기술을 살펴보겠습니다. 검색 최적화구글이나 네이버는 수많은 웹사이트를 수집해서 검색 시 결과를 보여줍니다. 이렇게 수집하는 작업을 크롤링이라고 합니다. 아무리 열심히 쓰고 내용이 좋다 하더라도 검색이 안되서 조회수가 없으면 아무 소용이 없겠죠. 검색 엔진 최적화 (SEO)란 검색 엔진에 잘 수집되서 검색 시 노출이 잘 되도록 하는 기술입니다. 이미 수많은 사람들이 최적화를 하고 있기 때문에 검색 시 노출되려면 필수적으로 해야 합니다. 해도 본전이고 안하면 노출이 거의 안되겠죠. 메타 태그메타 태그 (meta tag)는 해당 웹 페이지의 정보를 담은 태그로 &lt;head&gt; 태그 안에 있습니다. 웹 페이지에서 개발자 도구로 소스를 까보시면 확인할 수 있죠. 웹 페이지 제목, 설명, 소셜미디어 관련, 대표 URL, 반응형 웹 여부 등의 정보가 들어가 있습니다. 이 메타태그가 잘 들어가 있어야 검색 엔진이 이 사이트를 잘 인식해서 수집이 잘 됩니다. Hexo 와 테마에서 기본적으로 잘 넣어주지만 몇 가지 손볼 곳이 있습니다. 대표 URL 설정하기자동으로 메타 태그를 생성하는 것 중에 대표 URL 이 빠져있더군요. Hexo 플러그인을 이용해서 자동 생성해봅시다. Hexo 를 설치한 블로그 폴더에서 npm 을 이용해서 플러그인을 설치합니다. 1$ npm install --save hexo-auto-canonical 설치한 후에 &lt;head&gt; 태그 안에 대표 URL 속성을 집어넣어야겠죠? 다음을 복사해서 theme/hueman/layout/common/post/head.ejs 파일에 붙여넣습니다. 중간 쯤에 &lt;%- meta(page) %&gt; 라고 있는데 그 바로 아래 붙여넣으시면 됩니다. 1&lt;%- autoCanonical(config, page) %&gt; 이제 생성해서 배포해봅시다. 12$ hexo g$ hexo d 개발자도구를 통해 소스를 열어보면 &lt;head&gt; 태그에 cononical 속성이 추가된 것을 확인할 수 있습니다. 사실 Open Graph 관련해서도 추가해야 하지만 주제와 맞지 않으니 다음 포스트 때 이어서하기로 하고, 다음 내용으로 넘어가겠습니다. 구글 애널리틱스 (Google Analytics)먼저 구글 애널리틱스에 가입을 하겠습니다. 구글 애널리틱스는 웹 사이트의 방문현황과 통계를 다각도로 아주 자세하게 살펴볼 수 있는 툴입니다. 쉽게 말해서 방문자 통계입니다. 사이트 등록 전에 먼저 애널리틱스에 가입하는 이유는 사이트 등록 시 본인 사이트가 맞는지 인증을 해야하는데 애널리틱스와 연동해서 쉽게 인증이 가능하기 때문입니다. 나중에 가입하는 것보다 편합니다. 가입 후 속성을 등록합니다. 웹 사이트 이름, 웹 사이트 URL, 업종 카테고리, 보고 시간대 등을 설정하시면 추적 ID가 발급됩니다. 이 추적 ID는 Hueman 테마 폴더 안에 있는 _config.yml 에서 google_analytics 항목에 넣으면 메타 태그에 해당 항목이 자동으로 들어갑니다. 12plugins: google_analytics: UA-11111111-2 설정하고 서버에 배포하면 헤더의 메타 태그에서 확인할 수 있습니다. 처음에는 데이터가 없어서 정보가 없지만, 앞으로 차곡차곡 데이터가 쌓이겠군요. 구글 웹 마스터 도구 (Search Console)이제 웹 마스터 도구를 살펴봅시다. 예전 이름은 웹 마스터 도구였는데 현재 이름은 Search Console 입니다. Search Console 에 가입한 후에 속성을 추가합니다. 속성을 추가하면 페이지의 소유권을 확인하는 화면이 나옵니다. 주로 자동 생성된 html 파일을 루트에 올리고 확인하는 방식이 권장방법입니다. 하지만 우리는 애널리틱스를 미리 가입했기 때문에 대체 방법에서 ‘Google 애널리틱스’ 항목을 선택하면 바로 인증됩니다. 인증이 안되는 경우는 애널리틱스 아이디를 등록하고 배포를 안하신 경우이니 확인해보시기 바랍니다. 일단 사이트 등록을 마쳤습니다! 사이트를 추가한 후 몇가지 데이터들을 확인하는 데는 시간이 좀 걸립니다. 사이트에 해당하는 데이터를 수집해서 처리하려면 시간이 좀 걸린다고 하네요. Search Console에 사이트를 추가한 후 진단 및 기타 데이터를 사용할 수 있게 되기까지 다소 시간이 걸릴 수 있습니다. 이는 정상적인 현상입니다. Search Console에서 내 사이트에 해당하는 데이터를 수집하여 처리하려면 시간이 필요하기 때문입니다. 또한 www 와 www 없이 접속 둘 다 가능한 도메인이라면 둘 다 추가하고 선호 도메인 설정을 해놓으면 정확한 데이터를 얻을 수 있다고 합니다. 예를 들어 www.example.com 사이트 관련 데이터가 보이지 않는다면 http://example.com을 사용하여 사이트를 추가했기 때문일 수 있습니다. Google에게는 완전히 다른 사이트로 인식됩니다. 일부 데이터가 누락되었다고 판단되면 도메인의 www 버전과 www가 없는 버전을 모두 Search Console 계정에 추가합니다. 두 사이트 모두에 대해 데이터를 확인하세요. 하지만 Hexo는 www 가 붙지 않기 때문에 넘어가겠습니다. Search Console 과 애널리틱스 연동하기각각 설정한 이 두가지 서비스를 연동할 차례입니다. 연동을 하게 되면 애널리틱스 보고서에 관련 내용을 확인할 수 있습니다. 애널리틱스에 접속해서 관리 를 누르시고, 속성에 블로그가 있습니다. 해당 블로그의 속성 설정 에 들어가 맨 밑에 보면 Search Console 설정 이라는 버튼을 누르면 설정으로 이동합니다. 여기서 사이트를 추가하면 완료! 검색엔진 최적화 (Search Engine Optimization)이제부터는 본격적으로 최적화를 해보겠습니다. 사이트맵 (Sitemap)사이트맵은 사이트의 웹 페이지를 나열하는 파일로 현재 사이트가 어떻게 구성되어 있는지 검색엔진에게 알리는 용도로 사용됩니다. 크롤러가 사이트맵을 참조해 더 제대로 크롤링하게 도와주는 파일이라고 할 수 있습니다. 따라서 최신화된 사이트맵을 검색 엔진에게 제공하는건 중요한 일이라고 할 수 있습니다. 다음과 같은 경우일수록 중요하다고 하네요. 매우 큰 사이트. 크기로 인해 Google 웹 크롤러가 뉴스나 최근에 업데이트된 페이지를 간과할 수 있습니다. 서로 잘 연결되지 않거나 전혀 연결되지 않는 콘텐츠 페이지를 보관하는 대규모 자료실이 있는 사이트. 사이트 페이지가 서로 자연스럽게 참조하지 않는 경우 페이지를 사이트맵에 표시하면 Google이 일부 페이지를 간과하는 일이 생기지 않습니다. 연결되는 링크가 많지 않은 새로운 사이트. Googlebot과 다른 웹 크롤러는 한 페이지에서 다른 페이지로 연결되는 링크를 따라 이동하여 웹을 크롤링합니다. 따라서 다른 사이트가 링크되어 있지 않으면 Google에서 페이지를 찾지 못할 수 있습니다. 리치 미디어 콘텐츠를 사용하거나, Google 뉴스에 표시되거나, 기타 사이트맵 호환 사이트설정을 사용하는 사이트. Google이 사이트맵의 추가 정보를 검색에 적절하게 사용할 수 있습니다. 사이트맵 만들기 (XML, RSS)일단 사이트맵을 등록하려면 사이트맵 파일을 만들어야 합니다. XML 과 RSS 방식 등 여러가지 방법이 있는데요, Search Engine Journal의 이 포스팅을 보면 XML 과 RSS 방식 모두 사용하는 것이 좋다고 합니다. XML 은 전체 페이지에 대한 내용을 가지고 있고, RSS 는 최근 포스트에 대한 정보를 가지고 있기 때문이라고 하네요. 두개 다 만들어서 등록해보겠습니다. 사이트맵 자동 생성 플러그인구글에서 사이트맵 만드는 방법에 대해서 검색하면 많은 것들이 나오지만, Hexo 에는 자동으로 생성해주는 플러그인이 있습니다. 이 플러그인이 있으면 generate 할 때 자동으로 만들어주니까 신경 쓸 게 없죠. Hexo 가 설치된 폴더에서 진행합니다. 1$ npm install hexo-generator-seo-friendly-sitemap --save 플러그인을 설치 후에 해당 사이트의 _config.yml 파일에 다음과 같이 추가합니다. path 는 사이트맵이 자동 생성될 경로를 지정해줍니다. 이름은 그냥 sitemap.xml 로 하죠. 123# sitemap auto generatorsitemap: path: sitemap.xml RSS feed 자동 생성 플러그인이번에는 RSS feed 를 만들어보겠습니다. 예전에는 RSS feed 구독 많이 했었는데 요즘에는 인터넷 뉴스 볼 것이 많아지다보니 잘 활용을 안하게 되네요. RSS 도 자동으로 만들어주는 플러그인이 있습니다. 플러그인을 설치합니다. 1$ npm install hexo-generator-feed --save 설치 후에는 아까와 동일한 방식으로 _config.yml 에 아래와 같이 추가합니다. type 에는 atom 과 rss2 방식이 있다고 하네요. 둘 중 하나 골라서 넣으시고 이름은 feed.xml 로 하겠습니다. limit 은 포스트 몇 개까지 내용이 들어가느냐인데 0 이나 false 를 입력할 경우 모든 포스트를 등록한다고 합니다. 저는 그냥 false로 했습니다. 12345feed: type: atom path: feed.xml limit: 20 hub: 이제 생성해서 배포해봅시다. 12$ hexo g$ hexo d 그러면 root 에 sitemap.xml 과 feed.xml 이 생긴 것을 확인하실 수 있습니다. 사이트맵 제출이제 사이트맵을 제출해보겠습니다. Serach Console 의 크롤링 &gt; Sitemaps 에 들어가시면 SITEMAP 추가/ 테스트가 있습니다. 눌러서 생성했던 sitemap.xml 을 입력하면 제대로 제출이 됩니다. RSS 도 feed.xml 을 입력해서 등록합니다. 내가 제출한 사이트맵 메뉴에 사이트맵 목록이 나오는데요, 사이트가 변경이 되면 다시 접속해서 사이트맵을 선택하면 재제출 이라는 버튼이 있습니다. 이걸 누르면 변경 사항이 반영됩니다. 하루에 한번 정도는 다시 제출해야 좋다고 하네요. 워드프레스에는 자동으로 갱신되는 플러그인도 있다고 하던데 Hexo 에도 방법이 있는지 확인해봐야겠습니다. Fetch As GoogleFetch As Google 은 구글의 크롤링 담당하는 Googlebot 이라는 놈이 내 사이트를 어떻게 크롤링하는지 테스트하는 툴입니다. 주소를 넣고 가져오기 및 렌더링 을 눌러봅시다. 그러면 잠깐의 시간이 흐르고 완료되었다고 나오면, URL 색인을 제출합니다. 그런데 일부 완료라고 뜨거나 차단되었다고 뜰 때가 있습니다. 그러면 Googlebot이 모든 컨텐츠를 가져오는데 실패했다는 뜻입니다. 상태를 클릭하면 차단된 컨텐츠가 무엇이고 그것이 차단됨에 따라 검색에서 오는 불이익이 어느 정도인지 보여줍니다. Googlebot 이 보는 페이지와 일반 사용자가 보는 페이지를 비교해서 보여주는 기능도 있네요. 차단된 경우 해당 사유를 보고 조치하시면 되겠습니다. 자세히 알아보기 첨언하자면, robot.txt 라는 파일이 있는데 이 파일은 Googlebot 의 접근을 조절하는 파일입니다. Googlebot 은 크롤링할 때 이 파일을 참고해서 하는데 Googlebot 이 크롤링하지 않기를 바라는 부분을 정할 수 있습니다. 자세히 알아보기 간단한 사이트 등록부터 Console Search 를 이용한 조금 어려운 최적화 방법도 알아봤습니다. 다음 포스팅에서는 Open Graph 메타 태그 설정하는 방법을 알아보겠습니다. Related Posts 구글(Goolge) 사이트 등록(Search Console)과 검색엔진 최적화(SEO) 네이버 사이트 등록(웹마스터 도구)과 검색엔진 최적화(SEO) Hexo 블로그에 구글 애드센스(Adsense) 추가하기 오픈 그래프 (Open Graph) 태그와 페이스북 도메인 인사이트 (Domain Insight) 구글(Google) 검색 원리와 검색이 잘 되게 하는 방법 검색 엔진 최적화(SEO)에 유용한 Hexo 플러그인 구글 검색 상위 노출을 위한 200가지 팁","categories":[{"name":"Web","slug":"Web","permalink":"http://futurecreator.github.io/categories/Web/"},{"name":"Hexo","slug":"Web/Hexo","permalink":"http://futurecreator.github.io/categories/Web/Hexo/"}],"tags":[{"name":"web","slug":"web","permalink":"http://futurecreator.github.io/tags/web/"},{"name":"blog","slug":"blog","permalink":"http://futurecreator.github.io/tags/blog/"},{"name":"google","slug":"google","permalink":"http://futurecreator.github.io/tags/google/"},{"name":"search","slug":"search","permalink":"http://futurecreator.github.io/tags/search/"},{"name":"analytics","slug":"analytics","permalink":"http://futurecreator.github.io/tags/analytics/"}]},{"title":"Atom 을 마크다운(Markdown) 에디터로 사용하기","slug":"atom-as-markdown-editor","date":"2016-06-14T10:36:59.000Z","updated":"2016-07-04T14:09:17.000Z","comments":true,"path":"2016/06/14/atom-as-markdown-editor/","link":"","permalink":"http://futurecreator.github.io/2016/06/14/atom-as-markdown-editor/","excerpt":"","text":"요즘에 Markdown 문서를 작성할 일이 많아졌습니다. 그리고 마크다운 특유의 깔끔하고 정리된 레이아웃이 좋아서 자꾸 손이 가네요. 저는 Macbook과 Windows PC 모두 쓰고 있는데요, Mac이야 마크다운을 지원하는 좋은 유료 에디터들이 워낙 많지만 Windows에서는 딱히 마음에 드는 에디터가 없어서 고민이었습니다. 에디터로는 Notepad++과 Sublime Text를 쓰고 있었는데 실시간으로 마크다운 변환해서 볼 수 있는 Previewer를 지원하지 않고 Sublime Text 같은 경우는 한글 입력 시 한박자 늦게 입력되는 현상이 있죠. 이 현상을 해결하는 플러그인도 설치해봤지만 그래도 부자연스럽습니다. 그래서 갈아탄 에디터가 Atom입니다. Sublime Text 느낌이 많이 나네요. Sublime Text처럼 각종 플러그인을 설치할 수 있고 단축키를 몰라도 키보드로만 여러 명령을 내릴 수 있는 Command Palette도 지원하는 등 유사한 면이 많았습니다. 무엇보다도 한글 입력도 잘되고 마크다운 Previewer를 기본적으로 제공해서 마음에 들더군요. Atom을 설치하고 마크다운을 작성하기 편하게 설정을 해보죠. 설치하기설치는 Atom 다운로드 페이지에서 받아서 설치하면 끝! 설정하기단축키 ctrl + , 를 눌러 설정으로 들어갑니다. Settings 탭의 Soft wrap과 Scroll Past End 를 바꿔줍니다. Soft wrap: 자동줄바꿈 기능 Scroll Past End: 에디터가 마지막 줄이 되어도 스크롤을 더 내릴 수 있어 텍스트 입력을 편하게 해준다. 플러그인 설치하기아톰은 기본적으로 마크다운을 지원하는 플러그인이 설치되어 있습니다. 하지만 플러그인을 따로 설치하면 더 다양하고 편리한 기능을 사용할 수 있습니다. 설정의 Install 탭에서 검색한 후 설치하시면 됩니다. Markdown-preview-enhanced마크다운 관련 다양한 기능을 제공하는 Previewer입니다. 물론 아톰에서 기본적으로 제공하는 마크다운 문법과 프리뷰를 쓰셔도 좋습니다만, 다음과 같은 기능들을 보면 충분히 설치할 만합니다. Previewer 자동 스크롤 (2-way Scroll) 각종 수학식 입력 PDF와 HTML로 export 마크다운 Previewer 커스터마이징 (css) 이미지를 쉽게 넣을 수 있는 Image Helper [TOC] 생성 주석 입력 기타 다양한 기능들 상당히 많은 기능을 제공합니다. 웬만한 패키지에서 제공하는 기능을 모두 포함하고 있어서 이거 하나로도 충분합니다. command + shift + p 로 Command Palette를 열어 markdown preview enhanced 입력하면 실행 가능한 명령어들이 나옵니다. 특히 Image Helper 와 TOC 입력하는 게 유용하더군요. 마크다운은 이미지 넣기가 불편한데 Image Helper 기능은 파일을 바로 imgur에 올려서 url을 생성해줍니다. TOC는 자동으로 목차를 만들어주는 기능입니다. 또한 쉽게 테이블을 넣는 기능도 자주 사용합니다. Markdown-format Markdown-format 은 마크다운 문서를 저장하면 자동으로 포맷에 맞춰주는 플러그인입니다. 마크다운 문서를 항상 정리시켜줍니다. 요놈이 엄격해서 가끔 짜증날 때도 있는데 없으면 허전합니다 ㅋㅋ Markdown-folder 이 플러그인은 마크다운의 헤더를 접을 수 있게 해주는 플러그인입니다. 마크다운 문서 길이가 길어져서 복잡해질 때 헤더를 기준으로 하위 내용을 잠시 접어둘 수 있어서 정말 유용한 기능입니다. 아래의 코드를 keymap.cson 파일을 열어 맨 밑에 붙여넣으시면 tab 키로 간단하게 접었더 폈다 하실 수 있습니다. 다른 단축키들도 입맛대로 변경해서 사용하시면 되겠습니다. keymap.cson123456789101112'atom-text-editor[data-grammar=\"source gfm\"]:not([mini])': 'tab': 'markdown-folder:dwim-toggle' 'alt-c': 'markdown-folder:cycle' 'ctrl-alt-c': 'markdown-folder:cycleall' 'alt-x': 'markdown-folder:togglefenced' 'ctrl-alt-x': 'markdown-folder:toggleallfenced' 'alt-t': 'markdown-folder:toggle' 'ctrl-alt-1': 'markdown-folder:foldall-h1' 'ctrl-alt-2': 'markdown-folder:foldall-h2' 'ctrl-alt-3': 'markdown-folder:foldall-h3' 'ctrl-alt-4': 'markdown-folder:foldall-h4' 'ctrl-alt-5': 'markdown-folder:foldall-h5' 다만 작동하는 곳이 #, ##, ### 이런 식으로, # 으로 선언된 헤더만 해당하기 때문에 위에 Markdown-format 과는 맞지 않는 부분도 있습니다. 자동으로 formatting 해줄 때 # -&gt; ===, ## -&gt; --- 이런 식으로 자동변환하기 때문이죠. 둘 중 마음에 드는 걸 쓰시면 좋을 것 같습니다. 또한 헤더를 접은 상태에서는 프리뷰 싱크가 제대로 맞질 않습니다. 프리뷰는 제대로 보이지만 커서 위치 싱크가 맞지 않습니다. 이럴 때는 그냥 Command Palette 에서 프리뷰 화면의 Scroll Sync 를 잠시 끄고 쓰셔도 됩니다. 폰트와 테마 변경하기KoPub돋움체이제 폰트를 변경해봅시다. 폰트는 KoPub돋움체 를 강추합니다. 한국출판인회의의 전자출판진흥사업의 일환으로 무료로 제공하는 폰트인데 정말 깔끔합니다. 다른 무료 폰트들과 비교해놓은 걸 봤는데 이게 제일 마음에 들더군요. 마크다운의 깔끔한 레이아웃과 어울리는 가독성 높은 폰트입니다. 홈페이지에서 다운로드 받아서 설치하시면 됩니다. Settings 탭의 Font Family에 KoPubDotum을 입력하면 바로 적용됩니다. (Mac의 경우 KoPubDotum_Pro) 물론 Mac의 경우 기본 폰트인 Apple SD 산돌고딕 Neo 가 우수하니 굳이 바꾸시지 않아도 됩니다. Seti-ui 이번에는 테마를 변경해봅시다. Themes 탭에서 테마를 변경할 수 있습니다. UI Theme는 아톰 프로그램 전체의 스타일이고 Syntax Theme는 글을 편집하는 에디터의 스타일입니다. 마음에 드는 것을 선택하시거나 다른 사용자들이 만들어놓은 테마를 적용할 수 있습니다. 제가 추천하는 첫번째 테마는 Seti-ui 입니다. 어두운 색에 각 파일마다 속성을 표현하는 아이콘이 있어서 깔끔하군요. 설정의 Install 탭에서 Seti-ui로 테마를 검색하고 Install을 눌러 설치합니다. 설정에 Theme 탭에서 UI Theme를 Seti 로 변경합니다. 그럼 바로 적용되는 걸 볼 수 있습니다. Genesis-ui 제가 추천하는 두번째 테마는 Genesis-ui 입니다. 어두운 색감에 현재 파일과 탭만 밝게 표시되서 보기가 좋습니다. 또한 탭 크기도 작아서 화면도 넓게 쓸 수 있습니다. Seti-ui 처럼 알록달록하지 않고 모던한 느낌이라 좋습니다. Syntax ThemeSyntax 테마는 에디터 부분의 글 색깔, 화면 색깔 등을 변경하는 테마입니다. UI 테마 외에 Syntax 테마도 여러가지가 있으니 직접 보시고 원하시는 걸 선택하시면 됩니다. 개인적으로는 Solarized-light-ui 를 좋아합니다. 누런 화면이 눈이 피로해지는 걸 막아줍니다. 한 번 익숙해지면 눈이 한결 편합니다. 마크다운 작성하기 이제 마크다운 문서를 작성하면 되겠습니다. 실제로 이 글은 아톰을 이용해서 작성헀습니다. 제가 요즘에 사용하는 방식입니다. 프리뷰를 휴대폰에서 보는 것처럼 작게 해놓는 식으로 사용 중입니다. 웬만한 유료보다 괜찮은 마크다운 에디터입니다. 어차피 Hexo로 하려면 마크다운 뿐만 아니라 HTML, JavaScript, YAML 등 여러가지 파일을 다뤄야 하니까 아톰이 제격이긴 합니다. Mac 의 유료 마크다운 에디터인 Ulysses 와 ByWord 도 잠시 써봤지만 결국 Atom 으로 돌아왔습니다. 다음 번에는 Ulysses 와 ByWord 리뷰도 해보겠습니다.","categories":[{"name":"Web","slug":"Web","permalink":"http://futurecreator.github.io/categories/Web/"},{"name":"Markdown","slug":"Web/Markdown","permalink":"http://futurecreator.github.io/categories/Web/Markdown/"}],"tags":[{"name":"web","slug":"web","permalink":"http://futurecreator.github.io/tags/web/"},{"name":"markdown","slug":"markdown","permalink":"http://futurecreator.github.io/tags/markdown/"},{"name":"atom","slug":"atom","permalink":"http://futurecreator.github.io/tags/atom/"},{"name":"editor","slug":"editor","permalink":"http://futurecreator.github.io/tags/editor/"}]},{"title":"Hexo 추천 테마, Hueman 적용하기","slug":"hexo-apply-hueman-theme","date":"2016-06-14T10:25:48.000Z","updated":"2016-06-23T07:21:39.000Z","comments":true,"path":"2016/06/14/hexo-apply-hueman-theme/","link":"","permalink":"http://futurecreator.github.io/2016/06/14/hexo-apply-hueman-theme/","excerpt":"","text":"Hexo를 시작한 후 여러가지 테마를 적용해봤지만 이만한 테마가 없더군요. Hueman 이라는 테마로 깔끔하고 기능도 굉장히 다양합니다. 위젯이나 애드센스 이런 건 나중에 다루도록 하고 일단 테마에서 제공하는 기능들부터 살펴보겠습니다. 설치하기블로그 루트 폴더에서 명령어로 테마를 받습니다. 1$ git clone https://github.com/ppoffice/hexo-theme-hueman.git themes/hueman 그리고 블로그의 _config.yml을 수정합니다. 1theme: hueman 블로그의 _config.yml 말고 테마 폴더 안에 있는 _config.yml.example의 이름을 _config.yml로 수정합니다. 테마에서 제공하는 검색 기능 (Insight earch)를 이용하기 위해서는 hexo-generator-json-content를 설치해야 합니다. npm 을 이용해서 설치합니다. 1$ npm install -S hexo-generator-json-content 커스터마이징아까 이름을 변경했던 _config.yml 파일을 수정해서 각종 설정을 변경할 수 있습니다. 메뉴 필요한 것은 추가/ 수정할 수 있습니다. 하지만 포스팅할 때 front-matter에 카테고리를 추가하면 여기에 등록하지 않아도 자동으로 추가됩니다. front-matter는 포스트 첫머리에 있는 제목, 생성일자 등이 들어가는 부분을 말합니다. Example1234menu: Home: /hexo-theme-hueman/ About: /hexo-theme-hueman/about/index.html # 상대경로 GitHub: https://github.com # 절대 경로 About.me기본적으로 About 메뉴가 있는데 /about/index.html 이 없기 때문에 About 을 눌러 접속 시 404 에러가 나게 됩니다. About 페이지는 보통 블로그 주인에 대한 자기소개 페이지죠. 저는 굳이 따로 페이지를 만들지 않고 About.me 라는 사이트를 이용해서 만들었습니다. About.me 는 온라인 상의 자기 프로필, 자기소개 페이지입니다. 가입해서 프로필 이미지와 관심사, 디자인 등을 설정하면 자동으로 프로필 페이지를 만들어줍니다. 생성된 프로필 URL 을 여기에 입력하면 됩니다. 로고url을 해당 경로로 바꿔주면 됩니다. public 밑에 있는 img 폴더는 root폴더명/img라는 이름으로 접근 가능하고, 웹 상 이미지의 url도 가능합니다. 1234logo: width: 165 height: 60 url: images/logo-header.png 테마 색깔 테마 색깔이라고 해봐야 작은 부분이지만.. 변경 가능합니다. 1theme_color: '#d35' 하이라이트 하이라이트는 코드 블락에서 문법에 따라 내용의 색을 바꿔 보여주는 것을 말합니다 (Code Highlight). 그냥 기본적인 것으로 쓰셔도 좋고, 변경을 원하시면 hueman/source/css/_highlight 폴더에 있는 것들 중 골라서 사용하셔도 됩니다. 1highlight: androidstudio 사이드바사이드바의 위치를 조정할 수 있습니다. 1sidebar: left # options: left, right 썸네일포스트의 썸네일을 표시를 끄고 켤 수 있습니다. 1thumbnail: true 이 썸네일은 포스트 앞에 자동으로 삽입되는 front-matter 부분에 경로를 추가하면 됩니다. 123title: Hello Worlddate: 2013/7/13 20:46:25thumbnail: https://example.com/image.jpg 파비콘 (Favicon)파비콘은 URL앞에 붙는 작은 아이콘을 말합니다. ico는 잘 안되는 것 같고 png 파일로 했더니 잘 됩니다. 파비콘 파일의 경로를 지정해줍니다. 1favicon: favicon.png 파비콘이 안 바뀌는 경우파비콘을 제대로 설정해도 변경이 안되는 것처럼 보일 수 있습니다. 그럴 때는 다른 브라우저를 이용해서 확인해보시거나 크롬 브라우저의 파비콘 파일을 삭제한 후에 확인할 수 있습니다. 이럴 경우 다른 파비콘도 모두 삭제됩니다. 운영체제별 파비콘 파일 위치는 다음과 같습니다. 해당 폴더 안에 보시면 파비콘 파일이 있습니다. Windows 7 or Vista1C:\\Users\\%USERNAME%\\AppData\\Local\\Google\\Chrome\\User Data\\Default Mac OS X1~/Library/Application Support/Google/Chrome/Default Linux1~/.config/google-chrome/Default 소셜 링크 내가 사용하는 여러가지 SNS 주소를 표시할 수 있습니다. 아이콘은 FontAwesome에서 골라서 이름을 적고 링크될 url을 적으면 됩니다. 123social_links: github: https://github.com/ppoffice/hexo-theme-hueman youtube: https://youtube.com 위젯1234567widgets: - recent_posts # 최근 포스트 - category # 카테고리 - archive # 어카이브 - tag # 태그 - tagcloud # 태그클라우드. 사용된 태그들을 빈도수에 따라 구름처럼 표시 - links # 링크 사이드바에 추가되는 여러가지 위젯을 제공합니다. 사용하지 않는 것은 지워주면 되고 사용하려면 추가하면 됩니다. 이름만 보면 무슨 기능인지 아실 겁니다. 링크그 중에 링크는 _config.yml 하단에서 다음과 같이 추가 가능합니다. 12345# Miscellaneousmiscellaneous: links: Hexo: http://hexo.io Naver blog: http://blog.naver.com/future_creator 검색 블로그의 내의 검색 기능입니다. 몇가지 종류가 있는데 기본적으로 제공하는 Insight Search를 사용하시면 됩니다. 전에 살펴본 것처럼 기본적으로 hexo-generator-json-content를 설치해야 합니다. 12345# Searchsearch: insight: true swiftype: baidu: false 댓글 댓글은 기본적으로 Disqus를 제공합니다. 몇가지 더 제공하는데 중국 서비스라서 일단 Disqus를 사용하겠습니다. 디스커스에 먼저 가입하고 다음과 같이 아이디를 확인하고 _config.yml에 입력합니다. 12345# Commentcomment: disqus: futurecreator # disqus shortname 을 찾아 입력합니다. duoshuo: youyan: 공유해당 포스트를 공유하기 위한 기능도 제공합니다. 몇가지 옵션이 있습니다. 이미지를 보시고 원하시는 스타일을 사용하시면 됩니다. default addtoany jiathis (중국) bdshare (중국) 12# Shareshare: addtoany # options: jiathis, bdshare, addtoany, default 플러그인이외에도 Open Graph, ScrollLoading, Fancybox 등의 플러그인을 제공합니다. 1google_analytics: UA-66666666-6 ScrollLoading한번에 모든 페이지를 로딩하는 게 아니고 스크롤에 따라서 로딩하는 플러그인입니다. Fancybox맥 스타일로 이미지를 보여주는 플러그인이라고 하네요. 블로그 검색 관련 기능Open Graph와 Google Analytics와 연동 등을 제공합니다. 이 부분은 얘기가 또 길어지니까 다음번 포스트 때 자세히 다뤄보죠. Open Graph페이스북의 앱 아이디나 admin 번호, 트위터와 구글플러스 아이디를 입력할 수 있습니다. 12345open_graph: fb_app_id: fb_admins: twitter_id: google_plus: Google AnalyticsGoogle Analytics 아이디를 적으면 됩니다. 이런 기능들을 그냥 옵션으로 바로 적용할 수 있으니 정말 편합니다. 쓸수록 마음에 드는 테마입니다. 다음번에는 Hexo에 있는 플러그인들 중 쓸만한 걸 살펴보겠습니다. Related Posts 워드프레스보다 쉬운 Hexo 블로그 시작하기 Hexo 추천 테마, Hueman 적용하기 Hexo 기본 사용법 Hexo 태그 플러그인 (Tag plugins) 살펴보기 Hexo 네임카드 추가하기 (Github Card) Hexo 에 Github 저장소 타임라인 (Repository timeline) 정보 추가하기 구글(Goolge) 사이트 등록(Search Console)과 검색엔진 최적화(SEO) 네이버 사이트 등록(웹마스터 도구)과 검색엔진 최적화(SEO) Hexo 블로그에 구글 애드센스(Adsense) 추가하기 오픈 그래프 (Open Graph) 태그와 페이스북 도메인 인사이트 (Domain Insight) 구글(Google) 검색 원리와 검색이 잘 되게 하는 방법 검색 엔진 최적화(SEO)에 유용한 Hexo 플러그인","categories":[{"name":"Web","slug":"Web","permalink":"http://futurecreator.github.io/categories/Web/"},{"name":"Hexo","slug":"Web/Hexo","permalink":"http://futurecreator.github.io/categories/Web/Hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://futurecreator.github.io/tags/hexo/"},{"name":"blog","slug":"blog","permalink":"http://futurecreator.github.io/tags/blog/"},{"name":"theme","slug":"theme","permalink":"http://futurecreator.github.io/tags/theme/"},{"name":"plugin","slug":"plugin","permalink":"http://futurecreator.github.io/tags/plugin/"}]},{"title":"워드프레스보다 쉬운 Hexo 블로그 시작하기","slug":"get-started-with-hexo","date":"2016-06-14T07:44:00.000Z","updated":"2016-06-23T07:21:43.000Z","comments":true,"path":"2016/06/14/get-started-with-hexo/","link":"","permalink":"http://futurecreator.github.io/2016/06/14/get-started-with-hexo/","excerpt":"","text":"네이버 블로그를 시작하면서 아쉬웠던 점은 마크다운(Markdown) 언어를 지원하지 않는다는 점이었습니다. 그래서 Markdown here 라는 크롬 익스텐션을 이용해서 마크다운으로 렌더링하고 에디터에 붙여넣는 방식으로 블로그를 작성했습니다. 문제는 네이버 블로그의 스마트 에디터 와 호환이 제대로 되지 않는다는 점이었습니다. 열심히 작성했던 포스트가 모바일로 수정하면 깨져버리고, 마크다운에서 code를 작성하면 개행이 먹질 않는 등 문제가 있었습니다. 결국엔 내용은 마크다운 에디터로 작성을 하고 포스트할 때 이미지와 코드는 스마트 에디터 이용해서 작성합니다. 이중, 삼중으로 손이 많이 가는 작업이죠 ㅠㅠ 대체할 블로그를 찾던 중 제 마음에 든 놈은 이겁니다. Hexo라는 블로그 프레임워크인데 말그대로 쉽고 빠르고 강력합니다. 워드프레스처럼 어렵지도 않고 네이버보다는 내 맘대로 커스터마이징 할 수 있어서 마음에 쏙 들더군요. Hexo는 github pages를 이용한 블로그입니다. Github Pages 는 github 유저와 프로젝트의 정적인(static) 홈페이지를 자동으로 만들어주고 github.io 도메인으로 호스팅해주는 서비스입니다. 즉, 서버의 내용을 github 에 push만 하면 실시간 적용됩니다. 아주 간단하죠? Command Line 으로 간편하게 포스트 생성 및 관리 다양한 테마 적용 (github) 간편한 플러그인 적용 (npm) Github Pages 를 이용한 호스팅 마크다운 (Markdown) 지원 하지만 아무리 쉽다고 해도 어느정도 웹 프로그래밍에 대한 지식이 있는 사람 에 한합니다. 커맨드라인에서 작업을 하고, 레이아웃이나 템플릿 등을 이해하려면 기본적으로 HTML, CSS, JavaScript에 대해 알아야 할 것이고, git 의 개념에 대해서도 알아야할 것이고, 포스트도 마크다운으로 작성하니 일반 사람들에게는 아무래도 생소하고 어렵게 느껴지겠죠. Github 프로젝트 만들기먼저 블로그의 각종 설정과 포스트를 관리할 github repository를 먼저 만듭니다. github.com에 접속해 New Repository로 새로운 저장소를 만듭니다. 여기서 주의할 점이 사용자 페이지와 프로젝트 페이지 만드는 법이 다릅니다. 두 사이트의 가장 큰 차이는 url 입니다. url이 완전 달라집니다. 사용자 페이지의 경우 username.github.io 이렇게 만들어지지만, http://username.github.io/repository 이렇게 만들어집니다. 주소 자체를 루트로 가져가지 못하고 서브디렉토리가 루트가 됩니다. 저도 처음에는 잘 몰라서 프로젝트 페이지로 만들었고 원래 url이 이런가보다 하고 잘 쓰다가 나중에 페이스북 도메인 인사이트 등록할 때 루트가 아니라서 안된다고 나와서 충격받았습니다.. 그래서 다시 만드느라 고생했네요. 사용처가 분명히 다르니, 계정 대표 블로그라면 유저 페이지로 만드시길 바랍니다. 유저 페이지로 만들기 위해서는 repository 이름을 username.github.io으로 만드셔야 합니다. 저장소를 만드신 후에 clone 받아서 index.html만 넣어주시면 바로 접속 가능합니다. 하지만 우리는 Hexo 를 설치할 것이니까 그대로 진행합니다. 설치하기이번엔 Hexo를 설치해보죠. Node.js 와 Git 이 설치되어 있다면 아주 간단하게 설치할 수 있습니다. 1$ npm install -g hexo-cli 시작하기블로그 파일을 저장할 폴더를 하나 만듭니다. 여기에 블로그의 기본적인 구조를 만들겁니다. 이름을 myBlog라고 해보죠. 123$ hexo init myBlog$ cd myBlog$ npm install 그리고 나면 다음과 같은 폴더구조가 생성됩니다. 12345678.├── _config.yml├── package.json├── scaffolds├── source| ├── _drafts| └── _posts└── themes 바로 로컬서버를 띄워 확인해볼 수 있습니다.1$ hexo server 그러면 localhost:4000 에 접속하라고 뜨네요. 초기 상태의 블로그가 만들어졌습니다. 설정하기프로젝트 설정은 _config.yaml 파일을 수정하면 됩니다. 블로그의 전반적인 설정을 할 수 있는 파일입니다. 자세한 내용은 차근차근 알아보기로 하고 URL과 Deployment 부분을 다음과 같은 형식으로 지정해줍니다. 123456789101112131415161718# Sitetitle: Writer, IT Blog # 타이틀subtitle: Eirc Han's IT Blog using Hexo # 서브 타이틀description: Eirc Han's IT Blog using Hexo # 블로그 설명author: Eric Han # 저자 이름language: en # 기본 언어. 다국어 지원timezone: Asia/Seoul # 해당 타임존 설정 (https://en.wikipedia.org/wiki/List_of_tz_database_time_zones)# URLurl: http://futurecreator.github.io/ # 앞에서 만든 github page 주소root: / # 기본은 / 이고 만약 서브디렉토리 구조를 가진다면 루트를 지정하는 부분.permalink: :year/:month/:day/:title/ # 기본 permalink (고정 url). 새글 생성 시 자동으로 지정된 형식의 URL이 할당된다.permalink_defaults:# Deploymentdeploy: type: git repo: https://github.com/futureCreator/futurecreator.github.io.git 이제 github 도메인으로 접속하기 위해 배포를 합니다. github 에 push 해서 확인해보겠습니다. 12hexo generatehexo deploy 혹은 이렇게 한 줄로 할 수도 있습니다. 1hexo g -d 주로 로컬에서 포스트 작성, 설정 변경 등 작업을 하고 다 되면 배포하는 식으로 작업합니다. 배포가 되면 username.github.io 으로 접속해서 확인합니다. 제 경우에는 futurecreator.github.io 입니다. 포스트 작성하기이번에는 새 글을 하나 작성해보죠. 커맨드라인에서 다음과 같이 포스트를 생성합니다. 1$ hexo new post &apos;post name&apos; 그러면 [blogFolder]/source/_posts에 해당 이름의 새로운 마크다운 파일이 생성됩니다. 마크다운 파일을 열어 보면 맨 앞에 제목과 생성 날짜가 자동으로 들어가는데 이걸 front-matter 라고 합니다. 여러가지 내용이 들어갈 수 있는데 그냥 제목만 입력해보죠. 원하는 제목으로 수정하고 내용을 작성한 후에 로컬서버에서 확인해봅니다. 1hexo server 잘 보인다면 서버에 배포하고 확인해봅시다. 1hexo g -d Hexo를 설치하고 새 포스트를 작성하는 것까지 알아봤습니다. 길어보이지만 실제로는 거의 작업이 없습니다. 자세한 내용은 Hexo Docs를 참고하세요. 다음 번엔 테마를 바꾸고 여러 기능을 추가해보겠습니다. Related Posts 워드프레스보다 쉬운 Hexo 블로그 시작하기 Hexo 추천 테마, Hueman 적용하기 Hexo 기본 사용법 Hexo 태그 플러그인 (Tag plugins) 살펴보기 Hexo 네임카드 추가하기 (Github Card) Hexo 에 Github 저장소 타임라인 (Repository timeline) 정보 추가하기 구글(Goolge) 사이트 등록(Search Console)과 검색엔진 최적화(SEO) 네이버 사이트 등록(웹마스터 도구)과 검색엔진 최적화(SEO) Hexo 블로그에 구글 애드센스(Adsense) 추가하기 오픈 그래프 (Open Graph) 태그와 페이스북 도메인 인사이트 (Domain Insight) 구글(Google) 검색 원리와 검색이 잘 되게 하는 방법 검색 엔진 최적화(SEO)에 유용한 Hexo 플러그인","categories":[{"name":"Web","slug":"Web","permalink":"http://futurecreator.github.io/categories/Web/"},{"name":"Hexo","slug":"Web/Hexo","permalink":"http://futurecreator.github.io/categories/Web/Hexo/"}],"tags":[{"name":"web","slug":"web","permalink":"http://futurecreator.github.io/tags/web/"},{"name":"markdown","slug":"markdown","permalink":"http://futurecreator.github.io/tags/markdown/"},{"name":"hexo","slug":"hexo","permalink":"http://futurecreator.github.io/tags/hexo/"},{"name":"blog","slug":"blog","permalink":"http://futurecreator.github.io/tags/blog/"}]}]}